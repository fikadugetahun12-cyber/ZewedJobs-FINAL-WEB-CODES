#!/bin/bash

# Create js directory and all required files
mkdir -p js/{modules,utils}

echo "Creating JavaScript files for Zewed Jobs..."

# File 1: main.js
cat > js/main.js << 'EOF'
/**
 * main.js - Main application entry point for Zewed Jobs
 * @version 1.0.0
 * @author Zewed Jobs Team
 */

// Import modules
import { ApiClient, API_ENDPOINTS } from './api.js';
import { Translator } from './translator.js';
import { NotificationManager } from './notifications.js';
import { PaymentManager } from './modules/payment.js';
import { ChatBot } from './modules/chatbot.js';
import { AuthManager } from './modules/auth.js';
import { JobManager } from './modules/jobs.js';
import { 
  debounce, 
  throttle, 
  formatCurrency, 
  formatDate, 
  validateEmail,
  validatePhone,
  createLoadingSpinner,
  removeLoadingSpinner
} from './utils/helpers.js';

// Application configuration
const CONFIG = {
  API_BASE_URL: 'https://api.zewedjobs.com/v1',
  SOCKET_URL: 'wss://ws.zewedjobs.com',
  DEFAULT_LANG: 'en',
  THEME: 'light',
  CURRENCY: 'ETB',
  APP_VERSION: '1.0.0',
  DEBUG: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
};

// Global application state
const APP_STATE = {
  user: null,
  jobs: [],
  notifications: [],
  messages: [],
  language: localStorage.getItem('language') || CONFIG.DEFAULT_LANG,
  theme: localStorage.getItem('theme') || CONFIG.THEME,
  currency: localStorage.getItem('currency') || CONFIG.CURRENCY,
  authToken: localStorage.getItem('authToken') || null,
  isAuthenticated: !!localStorage.getItem('authToken'),
  isLoading: false,
  socket: null,
  paymentSession: null
};

// Application instance
class ZewedJobsApp {
  constructor() {
    this.api = new ApiClient(CONFIG.API_BASE_URL);
    this.translator = new Translator(APP_STATE.language);
    this.notifications = new NotificationManager();
    this.payment = new PaymentManager();
    this.chatbot = new ChatBot();
    this.auth = new AuthManager();
    this.jobs = new JobManager();
    
    this.initializeApp();
  }

  /**
   * Initialize the application
   */
  async initializeApp() {
    try {
      console.log('üöÄ Initializing Zewed Jobs Application...');
      
      // Set initial theme
      this.setTheme(APP_STATE.theme);
      
      // Load translations
      await this.translator.loadLanguage(APP_STATE.language);
      
      // Initialize components
      this.initializeComponents();
      
      // Set up event listeners
      this.setupEventListeners();
      
      // Check authentication status
      await this.checkAuthStatus();
      
      // Initialize WebSocket connection
      this.initWebSocket();
      
      // Load initial data
      await this.loadInitialData();
      
      // Show welcome notification
      this.notifications.show({
        title: this.translator.translate('welcome.title'),
        message: this.translator.translate('welcome.message'),
        type: 'success',
        duration: 3000
      });
      
      console.log('‚úÖ Application initialized successfully');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize application:', error);
      this.notifications.show({
        title: 'Initialization Error',
        message: 'Failed to initialize application. Please refresh the page.',
        type: 'error'
      });
    }
  }

  /**
   * Initialize UI components
   */
  initializeComponents() {
    // Initialize mobile menu
    this.initMobileMenu();
    
    // Initialize modals
    this.initModals();
    
    // Initialize dropdowns
    this.initDropdowns();
    
    // Initialize tooltips
    this.initTooltips();
    
    // Initialize lazy loading for images
    this.initLazyLoading();
    
    // Initialize form validations
    this.initFormValidations();
    
    // Initialize search functionality
    this.initSearch();
  }

  /**
   * Set up global event listeners
   */
  setupEventListeners() {
    // Language switcher
    document.querySelectorAll('[data-lang]').forEach(button => {
      button.addEventListener('click', (e) => {
        const lang = e.target.dataset.lang;
        this.switchLanguage(lang);
      });
    });

    // Theme switcher
    document.querySelectorAll('[data-theme]').forEach(button => {
      button.addEventListener('click', (e) => {
        const theme = e.target.dataset.theme;
        this.setTheme(theme);
      });
    });

    // Logout button
    const logoutBtn = document.getElementById('logout-btn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', () => this.logout());
    }

    // Notification bell
    const notificationBell = document.getElementById('notification-bell');
    if (notificationBell) {
      notificationBell.addEventListener('click', () => this.toggleNotifications());
    }

    // Search input
    const searchInput = document.getElementById('global-search');
    if (searchInput) {
      searchInput.addEventListener('input', debounce((e) => {
        this.performGlobalSearch(e.target.value);
      }, 300));
    }

    // Window resize
    window.addEventListener('resize', throttle(() => {
      this.handleResize();
    }, 200));

    // Online/Offline detection
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());

    // Before unload
    window.addEventListener('beforeunload', (e) => {
      if (this.hasUnsavedChanges()) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      this.handleKeyboardShortcuts(e);
    });
  }

  /**
   * Initialize mobile menu
   */
  initMobileMenu() {
    const menuToggle = document.querySelector('.mobile-menu-toggle');
    const mobileMenu = document.querySelector('.mobile-menu');
    
    if (menuToggle && mobileMenu) {
      menuToggle.addEventListener('click', () => {
        menuToggle.classList.toggle('active');
        mobileMenu.classList.toggle('active');
        document.body.classList.toggle('menu-open');
      });
      
      // Close menu when clicking outside
      document.addEventListener('click', (e) => {
        if (!mobileMenu.contains(e.target) && !menuToggle.contains(e.target)) {
          menuToggle.classList.remove('active');
          mobileMenu.classList.remove('active');
          document.body.classList.remove('menu-open');
        }
      });
    }
  }

  /**
   * Initialize modals
   */
  initModals() {
    const modals = document.querySelectorAll('.modal');
    
    modals.forEach(modal => {
      const openBtn = document.querySelector(`[data-modal="${modal.id}"]`);
      const closeBtn = modal.querySelector('.modal-close');
      
      if (openBtn) {
        openBtn.addEventListener('click', () => this.openModal(modal.id));
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => this.closeModal(modal.id));
      }
      
      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeModal(modal.id);
        }
      });
      
      // Close on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
          this.closeModal(modal.id);
        }
      });
    });
  }

  /**
   * Open a modal
   * @param {string} modalId - The ID of the modal to open
   */
  openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      // Focus on first input if exists
      const firstInput = modal.querySelector('input, textarea, select');
      if (firstInput) {
        setTimeout(() => firstInput.focus(), 100);
      }
    }
  }

  /**
   * Close a modal
   * @param {string} modalId - The ID of the modal to close
   */
  closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.classList.remove('active');
      document.body.style.overflow = '';
    }
  }

  /**
   * Initialize dropdowns
   */
  initDropdowns() {
    const dropdowns = document.querySelectorAll('.dropdown');
    
    dropdowns.forEach(dropdown => {
      const toggle = dropdown.querySelector('.dropdown-toggle');
      const menu = dropdown.querySelector('.dropdown-menu');
      
      if (toggle && menu) {
        toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown.classList.toggle('active');
        });
        
        // Close when clicking outside
        document.addEventListener('click', () => {
          dropdown.classList.remove('active');
        });
      }
    });
  }

  /**
   * Initialize tooltips
   */
  initTooltips() {
    const tooltips = document.querySelectorAll('[data-tooltip]');
    
    tooltips.forEach(element => {
      element.addEventListener('mouseenter', (e) => {
        const tooltipText = e.target.dataset.tooltip;
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.textContent = tooltipText;
        
        const rect = e.target.getBoundingClientRect();
        tooltip.style.top = `${rect.top - 40}px`;
        tooltip.style.left = `${rect.left + (rect.width / 2)}px`;
        tooltip.style.transform = 'translateX(-50%)';
        
        document.body.appendChild(tooltip);
        e.target._tooltip = tooltip;
      });
      
      element.addEventListener('mouseleave', (e) => {
        if (e.target._tooltip) {
          e.target._tooltip.remove();
          delete e.target._tooltip;
        }
      });
    });
  }

  /**
   * Initialize lazy loading for images
   */
  initLazyLoading() {
    if ('IntersectionObserver' in window) {
      const lazyImages = document.querySelectorAll('img[data-src]');
      
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            imageObserver.unobserve(img);
          }
        });
      });
      
      lazyImages.forEach(img => imageObserver.observe(img));
    } else {
      // Fallback for older browsers
      const lazyImages = document.querySelectorAll('img[data-src]');
      lazyImages.forEach(img => {
        img.src = img.dataset.src;
        img.removeAttribute('data-src');
      });
    }
  }

  /**
   * Initialize form validations
   */
  initFormValidations() {
    const forms = document.querySelectorAll('form[data-validate]');
    
    forms.forEach(form => {
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        if (await this.validateForm(form)) {
          await this.submitForm(form);
        }
      });
      
      // Real-time validation
      const inputs = form.querySelectorAll('input, textarea, select');
      inputs.forEach(input => {
        input.addEventListener('blur', () => {
          this.validateField(input);
        });
        
        input.addEventListener('input', () => {
          this.clearFieldError(input);
        });
      });
    });
  }

  /**
   * Validate a form
   * @param {HTMLFormElement} form - The form to validate
   * @returns {Promise<boolean>} - Whether the form is valid
   */
  async validateForm(form) {
    let isValid = true;
    const inputs = form.querySelectorAll('[data-validate]');
    
    for (const input of inputs) {
      if (!await this.validateField(input)) {
        isValid = false;
      }
    }
    
    return isValid;
  }

  /**
   * Validate a form field
   * @param {HTMLElement} field - The field to validate
   * @returns {Promise<boolean>} - Whether the field is valid
   */
  async validateField(field) {
    const value = field.value.trim();
    const rules = field.dataset.validate ? field.dataset.validate.split(' ') : [];
    
    // Clear previous errors
    this.clearFieldError(field);
    
    // Required validation
    if (rules.includes('required') && !value) {
      this.showFieldError(field, 'This field is required');
      return false;
    }
    
    // Email validation
    if (rules.includes('email') && value && !validateEmail(value)) {
      this.showFieldError(field, 'Please enter a valid email address');
      return false;
    }
    
    // Phone validation
    if (rules.includes('phone') && value && !validatePhone(value)) {
      this.showFieldError(field, 'Please enter a valid phone number');
      return false;
    }
    
    // Password validation
    if (rules.includes('password') && value && value.length < 8) {
      this.showFieldError(field, 'Password must be at least 8 characters');
      return false;
    }
    
    // Confirm password validation
    if (rules.includes('confirm') && value) {
      const passwordField = document.querySelector('[name="password"]');
      if (passwordField && value !== passwordField.value) {
        this.showFieldError(field, 'Passwords do not match');
        return false;
      }
    }
    
    return true;
  }

  /**
   * Show error for a field
   * @param {HTMLElement} field - The field
   * @param {string} message - Error message
   */
  showFieldError(field, message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'field-error';
    errorDiv.textContent = message;
    
    field.classList.add('error');
    field.parentNode.appendChild(errorDiv);
  }

  /**
   * Clear error for a field
   * @param {HTMLElement} field - The field
   */
  clearFieldError(field) {
    field.classList.remove('error');
    
    const existingError = field.parentNode.querySelector('.field-error');
    if (existingError) {
      existingError.remove();
    }
  }

  /**
   * Submit a form
   * @param {HTMLFormElement} form - The form to submit
   */
  async submitForm(form) {
    const formData = new FormData(form);
    const action = form.action;
    const method = form.method || 'POST';
    
    try {
      createLoadingSpinner(form);
      
      const response = await fetch(action, {
        method: method,
        body: method === 'GET' ? null : formData,
        headers: {
          'Authorization': `Bearer ${APP_STATE.authToken}`
        }
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.notifications.show({
          title: 'Success',
          message: data.message || 'Operation completed successfully',
          type: 'success'
        });
        
        // Trigger success callback if exists
        if (form.dataset.success) {
          const successCallback = new Function(form.dataset.success);
          successCallback();
        }
        
        // Close modal if form is in modal
        const modal = form.closest('.modal');
        if (modal) {
          this.closeModal(modal.id);
        }
        
        form.reset();
      } else {
        throw new Error(data.message || 'An error occurred');
      }
      
    } catch (error) {
      this.notifications.show({
        title: 'Error',
        message: error.message,
        type: 'error'
      });
    } finally {
      removeLoadingSpinner(form);
    }
  }

  /**
   * Initialize search functionality
   */
  initSearch() {
    const searchForms = document.querySelectorAll('.search-form');
    
    searchForms.forEach(form => {
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const searchInput = form.querySelector('input[type="search"]');
        if (searchInput) {
          await this.performSearch(searchInput.value, form.dataset.type || 'global');
        }
      });
    });
  }

  /**
   * Perform search
   * @param {string} query - Search query
   * @param {string} type - Search type (jobs, users, etc.)
   */
  async performSearch(query, type = 'global') {
    if (!query.trim()) return;
    
    try {
      createLoadingSpinner(document.querySelector('.search-results'));
      
      const response = await this.api.search({ query, type });
      
      if (response.success) {
        this.displaySearchResults(response.data, type);
      } else {
        throw new Error(response.message);
      }
      
    } catch (error) {
      this.notifications.show({
        title: 'Search Error',
        message: error.message,
        type: 'error'
      });
    } finally {
      removeLoadingSpinner(document.querySelector('.search-results'));
    }
  }

  /**
   * Perform global search
   * @param {string} query - Search query
   */
  async performGlobalSearch(query) {
    if (query.length < 2) return;
    
    try {
      const response = await this.api.search({ query, type: 'global' });
      
      if (response.success) {
        this.updateSearchSuggestions(response.data);
      }
    } catch (error) {
      console.error('Search error:', error);
    }
  }

  /**
   * Update search suggestions
   * @param {Array} suggestions - Search suggestions
   */
  updateSearchSuggestions(suggestions) {
    const suggestionsContainer = document.querySelector('.search-suggestions');
    if (!suggestionsContainer) return;
    
    suggestionsContainer.innerHTML = '';
    
    if (suggestions.length === 0) {
      suggestionsContainer.innerHTML = '<div class="no-results">No results found</div>';
      return;
    }
    
    suggestions.forEach(item => {
      const suggestion = document.createElement('a');
      suggestion.href = item.url;
      suggestion.className = 'search-suggestion';
      suggestion.innerHTML = `
        <div class="suggestion-icon">${item.icon || 'üîç'}</div>
        <div class="suggestion-content">
          <div class="suggestion-title">${item.title}</div>
          <div class="suggestion-category">${item.category}</div>
        </div>
      `;
      
      suggestionsContainer.appendChild(suggestion);
    });
    
    suggestionsContainer.classList.add('active');
  }

  /**
   * Display search results
   * @param {Array} results - Search results
   * @param {string} type - Result type
   */
  displaySearchResults(results, type) {
    const resultsContainer = document.querySelector('.search-results');
    if (!resultsContainer) return;
    
    resultsContainer.innerHTML = '';
    
    if (results.length === 0) {
      resultsContainer.innerHTML = `
        <div class="no-results">
          <i class="no-results-icon">üîç</i>
          <h3>No ${type} found</h3>
          <p>Try different keywords or browse categories</p>
        </div>
      `;
      return;
    }
    
    results.forEach(result => {
      const resultElement = this.createSearchResultElement(result, type);
      resultsContainer.appendChild(resultElement);
    });
    
    resultsContainer.classList.add('active');
  }

  /**
   * Create search result element
   * @param {Object} result - Result data
   * @param {string} type - Result type
   * @returns {HTMLElement} - Result element
   */
  createSearchResultElement(result, type) {
    const div = document.createElement('div');
    div.className = 'search-result';
    
    switch (type) {
      case 'jobs':
        div.innerHTML = `
          <div class="job-card">
            <h4>${result.title}</h4>
            <p class="company">${result.company}</p>
            <p class="location">üìç ${result.location}</p>
            <p class="salary">${formatCurrency(result.salary, APP_STATE.currency)}</p>
            <a href="/jobs/${result.id}" class="btn btn-sm">View Job</a>
          </div>
        `;
        break;
        
      default:
        div.innerHTML = `
          <a href="${result.url}" class="search-result-item">
            <h4>${result.title}</h4>
            <p>${result.description}</p>
          </a>
        `;
    }
    
    return div;
  }

  /**
   * Switch language
   * @param {string} lang - Language code (en, am, etc.)
   */
  async switchLanguage(lang) {
    try {
      await this.translator.switchLanguage(lang);
      APP_STATE.language = lang;
      localStorage.setItem('language', lang);
      
      // Update language in API headers
      this.api.setLanguage(lang);
      
      // Update UI elements
      document.documentElement.lang = lang;
      
      this.notifications.show({
        title: this.translator.translate('language.switched'),
        message: this.translator.translate('language.switched_message'),
        type: 'success',
        duration: 2000
      });
      
    } catch (error) {
      console.error('Language switch error:', error);
    }
  }

  /**
   * Set theme
   * @param {string} theme - Theme name (light, dark)
   */
  setTheme(theme) {
    APP_STATE.theme = theme;
    localStorage.setItem('theme', theme);
    
    document.documentElement.setAttribute('data-theme', theme);
    
    // Update theme toggle buttons
    document.querySelectorAll('[data-theme]').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.theme === theme);
    });
  }

  /**
   * Toggle theme
   */
  toggleTheme() {
    const newTheme = APP_STATE.theme === 'light' ? 'dark' : 'light';
    this.setTheme(newTheme);
  }

  /**
   * Handle window resize
   */
  handleResize() {
    // Update mobile menu state
    const mobileMenu = document.querySelector('.mobile-menu');
    if (window.innerWidth > 768 && mobileMenu) {
      mobileMenu.classList.remove('active');
      document.querySelector('.mobile-menu-toggle')?.classList.remove('active');
      document.body.classList.remove('menu-open');
    }
    
    // Update responsive classes
    document.body.classList.toggle('is-mobile', window.innerWidth < 768);
    document.body.classList.toggle('is-tablet', window.innerWidth >= 768 && window.innerWidth < 1024);
    document.body.classList.toggle('is-desktop', window.innerWidth >= 1024);
  }

  /**
   * Handle online status
   */
  handleOnline() {
    this.notifications.show({
      title: 'You\'re back online',
      message: 'Connection restored',
      type: 'success',
      duration: 3000
    });
    
    // Sync any pending data
    this.syncPendingData();
  }

  /**
   * Handle offline status
   */
  handleOffline() {
    this.notifications.show({
      title: 'You\'re offline',
      message: 'Some features may be unavailable',
      type: 'warning',
      duration: 5000
    });
  }

  /**
   * Sync pending data
   */
  async syncPendingData() {
    const pending = JSON.parse(localStorage.getItem('pending_sync') || '[]');
    
    if (pending.length > 0) {
      for (const item of pending) {
        try {
          await this.api.post(item.endpoint, item.data);
        } catch (error) {
          console.error('Sync error:', error);
        }
      }
      
      localStorage.removeItem('pending_sync');
    }
  }

  /**
   * Handle keyboard shortcuts
   * @param {KeyboardEvent} e - Keyboard event
   */
  handleKeyboardShortcuts(e) {
    // Ctrl/Cmd + K for search
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
      e.preventDefault();
      const searchInput = document.querySelector('#global-search');
      if (searchInput) {
        searchInput.focus();
      }
    }
    
    // Escape to close modals
    if (e.key === 'Escape') {
      const activeModal = document.querySelector('.modal.active');
      if (activeModal) {
        this.closeModal(activeModal.id);
      }
    }
  }

  /**
   * Check if there are unsaved changes
   * @returns {boolean} - True if unsaved changes exist
   */
  hasUnsavedChanges() {
    const forms = document.querySelectorAll('form[data-dirty]');
    return forms.length > 0;
  }

  /**
   * Check authentication status
   */
  async checkAuthStatus() {
    if (APP_STATE.authToken) {
      try {
        const response = await this.api.get('/auth/verify');
        if (response.success) {
          APP_STATE.user = response.data.user;
          APP_STATE.isAuthenticated = true;
          this.updateAuthUI(true);
        } else {
          this.clearAuth();
        }
      } catch (error) {
        this.clearAuth();
      }
    } else {
      this.updateAuthUI(false);
    }
  }

  /**
   * Clear authentication data
   */
  clearAuth() {
    APP_STATE.authToken = null;
    APP_STATE.user = null;
    APP_STATE.isAuthenticated = false;
    
    localStorage.removeItem('authToken');
    localStorage.removeItem('user');
    
    this.updateAuthUI(false);
    
    // Redirect to login if on protected page
    if (this.isProtectedPage()) {
      window.location.href = '/login';
    }
  }

  /**
   * Update authentication UI
   * @param {boolean} isAuthenticated - Authentication status
   */
  updateAuthUI(isAuthenticated) {
    const authElements = document.querySelectorAll('.auth-only');
    const guestElements = document.querySelectorAll('.guest-only');
    
    if (isAuthenticated) {
      authElements.forEach(el => el.style.display = '');
      guestElements.forEach(el => el.style.display = 'none');
      
      // Update user info
      const userMenu = document.querySelector('.user-menu');
      if (userMenu && APP_STATE.user) {
        const userName = userMenu.querySelector('.user-name');
        const userAvatar = userMenu.querySelector('.user-avatar');
        
        if (userName) {
          userName.textContent = APP_STATE.user.name;
        }
        
        if (userAvatar) {
          userAvatar.src = APP_STATE.user.avatar || '/images/default-avatar.png';
          userAvatar.alt = APP_STATE.user.name;
        }
      }
    } else {
      authElements.forEach(el => el.style.display = 'none');
      guestElements.forEach(el => el.style.display = '');
    }
  }

  /**
   * Check if current page is protected
   * @returns {boolean} - True if page is protected
   */
  isProtectedPage() {
    const protectedPaths = ['/dashboard', '/profile', '/settings', '/payments'];
    return protectedPaths.some(path => window.location.pathname.startsWith(path));
  }

  /**
   * Logout user
   */
  async logout() {
    try {
      await this.api.post('/auth/logout');
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      this.clearAuth();
      
      this.notifications.show({
        title: 'Logged out',
        message: 'You have been successfully logged out',
        type: 'success',
        duration: 3000
      });
      
      // Redirect to home
      setTimeout(() => {
        window.location.href = '/';
      }, 1500);
    }
  }

  /**
   * Toggle notifications panel
   */
  toggleNotifications() {
    const panel = document.getElementById('notifications-panel');
    if (panel) {
      panel.classList.toggle('active');
      
      if (panel.classList.contains('active')) {
        this.markNotificationsAsRead();
      }
    }
  }

  /**
   * Mark notifications as read
   */
  async markNotificationsAsRead() {
    try {
      await this.api.post('/notifications/read');
      
      const notificationBadge = document.querySelector('.notification-badge');
      if (notificationBadge) {
        notificationBadge.style.display = 'none';
      }
    } catch (error) {
      console.error('Mark notifications as read error:', error);
    }
  }

  /**
   * Initialize WebSocket connection
   */
  initWebSocket() {
    if (!APP_STATE.authToken) return;
    
    try {
      const socket = new WebSocket(`${CONFIG.SOCKET_URL}?token=${APP_STATE.authToken}`);
      
      socket.onopen = () => {
        console.log('WebSocket connected');
        APP_STATE.socket = socket;
      };
      
      socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleWebSocketMessage(data);
      };
      
      socket.onclose = () => {
        console.log('WebSocket disconnected');
        APP_STATE.socket = null;
        
        // Try to reconnect after 5 seconds
        setTimeout(() => this.initWebSocket(), 5000);
      };
      
      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
      
    } catch (error) {
      console.error('WebSocket initialization error:', error);
    }
  }

  /**
   * Handle WebSocket messages
   * @param {Object} data - Message data
   */
  handleWebSocketMessage(data) {
    switch (data.type) {
      case 'notification':
        this.notifications.show(data.notification);
        this.updateNotificationBadge();
        break;
        
      case 'message':
        if (this.chatbot) {
          this.chatbot.receiveMessage(data.message);
        }
        break;
        
      case 'payment_update':
        if (this.payment) {
          this.payment.handleUpdate(data.payment);
        }
        break;
        
      case 'job_alert':
        this.handleJobAlert(data.job);
        break;
    }
  }

  /**
   * Update notification badge
   */
  updateNotificationBadge() {
    const badge = document.querySelector('.notification-badge');
    if (badge) {
      const count = parseInt(badge.textContent) || 0;
      badge.textContent = count + 1;
      badge.style.display = 'block';
    }
  }

  /**
   * Handle job alert
   * @param {Object} job - Job data
   */
  handleJobAlert(job) {
    this.notifications.show({
      title: 'New Job Alert',
      message: `New job matching your criteria: ${job.title}`,
      type: 'info',
      duration: 5000,
      action: {
        label: 'View Job',
        callback: () => {
          window.location.href = `/jobs/${job.id}`;
        }
      }
    });
  }

  /**
   * Load initial data
   */
  async loadInitialData() {
    try {
      // Load jobs if on jobs page
      if (window.location.pathname === '/jobs' || window.location.pathname === '/') {
        await this.loadJobs();
      }
      
      // Load notifications if authenticated
      if (APP_STATE.isAuthenticated) {
        await this.loadNotifications();
      }
      
      // Load user profile if on profile page
      if (window.location.pathname === '/profile') {
        await this.loadUserProfile();
      }
      
    } catch (error) {
      console.error('Load initial data error:', error);
    }
  }

  /**
   * Load jobs
   */
  async loadJobs() {
    try {
      const response = await this.api.get('/jobs');
      if (response.success) {
        APP_STATE.jobs = response.data.jobs;
        this.renderJobs(APP_STATE.jobs);
      }
    } catch (error) {
      console.error('Load jobs error:', error);
    }
  }

  /**
   * Render jobs
   * @param {Array} jobs - Jobs array
   */
  renderJobs(jobs) {
    const container = document.getElementById('jobs-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    jobs.forEach(job => {
      const jobElement = this.createJobElement(job);
      container.appendChild(jobElement);
    });
  }

  /**
   * Create job element
   * @param {Object} job - Job data
   * @returns {HTMLElement} - Job element
   */
  createJobElement(job) {
    const div = document.createElement('div');
    div.className = 'job-card';
    div.innerHTML = `
      <div class="job-header">
        <h3 class="job-title">${job.title}</h3>
        <span class="job-salary">${formatCurrency(job.salary, APP_STATE.currency)}</span>
      </div>
      <div class="job-company">
        <img src="${job.company.logo}" alt="${job.company.name}" class="company-logo">
        <span class="company-name">${job.company.name}</span>
      </div>
      <div class="job-details">
        <span class="job-location">üìç ${job.location}</span>
        <span class="job-type">${job.type}</span>
        <span class="job-posted">${formatDate(job.posted_at)}</span>
      </div>
      <div class="job-description">${job.description.substring(0, 150)}...</div>
      <div class="job-actions">
        <a href="/jobs/${job.id}" class="btn btn-primary">View Details</a>
        <button class="btn btn-secondary save-job" data-job-id="${job.id}">Save</button>
      </div>
    `;
    
    return div;
  }

  /**
   * Load notifications
   */
  async loadNotifications() {
    try {
      const response = await this.api.get('/notifications');
      if (response.success) {
        APP_STATE.notifications = response.data.notifications;
        this.renderNotifications(APP_STATE.notifications);
      }
    } catch (error) {
      console.error('Load notifications error:', error);
    }
  }

  /**
   * Render notifications
   * @param {Array} notifications - Notifications array
   */
  renderNotifications(notifications) {
    const container = document.getElementById('notifications-list');
    if (!container) return;
    
    container.innerHTML = '';
    
    notifications.forEach(notification => {
      const notificationElement = this.createNotificationElement(notification);
      container.appendChild(notificationElement);
    });
  }

  /**
   * Create notification element
   * @param {Object} notification - Notification data
   * @returns {HTMLElement} - Notification element
   */
  createNotificationElement(notification) {
    const div = document.createElement('div');
    div.className = `notification-item ${notification.read ? 'read' : 'unread'}`;
    div.innerHTML = `
      <div class="notification-icon">${this.getNotificationIcon(notification.type)}</div>
      <div class="notification-content">
        <div class="notification-title">${notification.title}</div>
        <div class="notification-message">${notification.message}</div>
        <div class="notification-time">${formatDate(notification.created_at)}</div>
      </div>
      ${!notification.read ? '<div class="notification-dot"></div>' : ''}
    `;
    
    div.addEventListener('click', () => {
      this.handleNotificationClick(notification);
    });
    
    return div;
  }

  /**
   * Get notification icon
   * @param {string} type - Notification type
   * @returns {string} - Icon emoji
   */
  getNotificationIcon(type) {
    const icons = {
      info: '‚ÑπÔ∏è',
      success: '‚úÖ',
      warning: '‚ö†Ô∏è',
      error: '‚ùå',
      payment: 'üí∞',
      job: 'üíº',
      message: 'üí¨'
    };
    
    return icons[type] || 'üîî';
  }

  /**
   * Handle notification click
   * @param {Object} notification - Notification data
   */
  handleNotificationClick(notification) {
    // Mark as read
    this.api.post(`/notifications/${notification.id}/read`);
    
    // Navigate to action if exists
    if (notification.action_url) {
      window.location.href = notification.action_url;
    }
  }

  /**
   * Load user profile
   */
  async loadUserProfile() {
    try {
      const response = await this.api.get('/profile');
      if (response.success) {
        this.renderUserProfile(response.data);
      }
    } catch (error) {
      console.error('Load user profile error:', error);
    }
  }

  /**
   * Render user profile
   * @param {Object} profile - Profile data
   */
  renderUserProfile(profile) {
    // Update form fields
    const fields = ['name', 'email', 'phone', 'location', 'bio'];
    
    fields.forEach(field => {
      const element = document.querySelector(`[name="${field}"]`);
      if (element && profile[field]) {
        element.value = profile[field];
      }
    });
    
    // Update avatar
    const avatar = document.querySelector('.profile-avatar');
    if (avatar && profile.avatar) {
      avatar.src = profile.avatar;
    }
  }
}

// Initialize application when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Create global app instance
  window.ZewedJobs = new ZewedJobsApp();
  
  // Expose utilities globally for debugging
  if (CONFIG.DEBUG) {
    window.AppState = APP_STATE;
    window.AppConfig = CONFIG;
  }
});

// Export for module usage
export { ZewedJobsApp, APP_STATE, CONFIG };
EOF
echo "‚úÖ Created: js/main.js"

# File 2: api.js
cat > js/api.js << 'EOF'
/**
 * api.js - API communication module for Zewed Jobs
 * @version 1.0.0
 */

// API endpoints configuration
export const API_ENDPOINTS = {
  // Authentication
  AUTH: {
    LOGIN: '/auth/login',
    REGISTER: '/auth/register',
    LOGOUT: '/auth/logout',
    VERIFY: '/auth/verify',
    REFRESH: '/auth/refresh',
    FORGOT_PASSWORD: '/auth/forgot-password',
    RESET_PASSWORD: '/auth/reset-password'
  },
  
  // Users
  USERS: {
    PROFILE: '/users/profile',
    UPDATE: '/users/update',
    UPLOAD_AVATAR: '/users/upload-avatar',
    CHANGE_PASSWORD: '/users/change-password'
  },
  
  // Jobs
  JOBS: {
    LIST: '/jobs',
    CREATE: '/jobs',
    GET: '/jobs/:id',
    UPDATE: '/jobs/:id',
    DELETE: '/jobs/:id',
    APPLY: '/jobs/:id/apply',
    SAVE: '/jobs/:id/save',
    SEARCH: '/jobs/search',
    CATEGORIES: '/jobs/categories',
    LOCATIONS: '/jobs/locations'
  },
  
  // Applications
  APPLICATIONS: {
    LIST: '/applications',
    GET: '/applications/:id',
    STATUS: '/applications/:id/status',
    WITHDRAW: '/applications/:id/withdraw'
  },
  
  // Payments
  PAYMENTS: {
    INITIATE: '/payments/initiate',
    VERIFY: '/payments/verify',
    HISTORY: '/payments/history',
    INVOICE: '/payments/:id/invoice',
    METHODS: '/payments/methods',
    SUBSCRIPTIONS: '/payments/subscriptions'
  },
  
  // Notifications
  NOTIFICATIONS: {
    LIST: '/notifications',
    MARK_READ: '/notifications/read',
    MARK_ALL_READ: '/notifications/read-all',
    DELETE: '/notifications/:id',
    SETTINGS: '/notifications/settings'
  },
  
  // Messages
  MESSAGES: {
    LIST: '/messages',
    SEND: '/messages',
    CONVERSATIONS: '/messages/conversations',
    MARK_READ: '/messages/read'
  },
  
  // AI Chat
  AI_CHAT: {
    CHAT: '/ai/chat',
    HISTORY: '/ai/history',
    CLEAR: '/ai/clear'
  },
  
  // Analytics
  ANALYTICS: {
    DASHBOARD: '/analytics/dashboard',
    JOBS: '/analytics/jobs',
    APPLICATIONS: '/analytics/applications',
    PAYMENTS: '/analytics/payments'
  },
  
  // Settings
  SETTINGS: {
    GET: '/settings',
    UPDATE: '/settings/update',
    EMAIL: '/settings/email',
    NOTIFICATIONS: '/settings/notifications'
  }
};

// HTTP methods
const HTTP_METHODS = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  PATCH: 'PATCH',
  DELETE: 'DELETE'
};

// API error types
const API_ERRORS = {
  NETWORK_ERROR: 'NETWORK_ERROR',
  TIMEOUT_ERROR: 'TIMEOUT_ERROR',
  AUTH_ERROR: 'AUTH_ERROR',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  SERVER_ERROR: 'SERVER_ERROR',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR'
};

/**
 * API Client class
 */
export class ApiClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.options = {
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      },
      ...options
    };
    
    this.interceptors = {
      request: [],
      response: []
    };
    
    this.initialize();
  }
  
  /**
   * Initialize the API client
   */
  initialize() {
    // Load auth token from localStorage
    this.authToken = localStorage.getItem('authToken');
    this.language = localStorage.getItem('language') || 'en';
    
    // Update headers
    if (this.authToken) {
      this.setAuthToken(this.authToken);
    }
    
    this.setLanguage(this.language);
  }
  
  /**
   * Set authentication token
   * @param {string} token - JWT token
   */
  setAuthToken(token) {
    this.authToken = token;
    this.options.headers['Authorization'] = `Bearer ${token}`;
  }
  
  /**
   * Set language for API requests
   * @param {string} lang - Language code
   */
  setLanguage(lang) {
    this.language = lang;
    this.options.headers['Accept-Language'] = lang;
  }
  
  /**
   * Add request interceptor
   * @param {Function} interceptor - Interceptor function
   */
  addRequestInterceptor(interceptor) {
    this.interceptors.request.push(interceptor);
  }
  
  /**
   * Add response interceptor
   * @param {Function} interceptor - Interceptor function
   */
  addResponseInterceptor(interceptor) {
    this.interceptors.response.push(interceptor);
  }
  
  /**
   * Execute request with interceptors
   * @param {string} url - Request URL
   * @param {Object} options - Request options
   * @returns {Promise} - Response promise
   */
  async request(url, options = {}) {
    const requestOptions = {
      ...this.options,
      ...options,
      headers: {
        ...this.options.headers,
        ...options.headers
      }
    };
    
    // Apply request interceptors
    let processedOptions = requestOptions;
    for (const interceptor of this.interceptors.request) {
      processedOptions = await interceptor(processedOptions);
    }
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), processedOptions.timeout);
    
    try {
      const response = await fetch(`${this.baseURL}${url}`, {
        ...processedOptions,
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      // Apply response interceptors
      let processedResponse = response;
      for (const interceptor of this.interceptors.response) {
        processedResponse = await interceptor(processedResponse);
      }
      
      return this.handleResponse(processedResponse);
      
    } catch (error) {
      clearTimeout(timeoutId);
      return this.handleError(error);
    }
  }
  
  /**
   * Handle API response
   * @param {Response} response - Fetch response
   * @returns {Promise} - Processed response
   */
  async handleResponse(response) {
    const contentType = response.headers.get('content-type');
    
    let data;
    if (contentType && contentType.includes('application/json')) {
      data = await response.json();
    } else {
      data = await response.text();
    }
    
    if (!response.ok) {
      throw {
        type: this.getErrorType(response.status),
        status: response.status,
        message: data.message || response.statusText,
        data: data,
        originalError: null
      };
    }
    
    return {
      success: true,
      status: response.status,
      data: data.data || data,
      message: data.message,
      meta: data.meta,
      timestamp: new Date().toISOString()
    };
  }
  
  /**
   * Handle API error
   * @param {Error} error - Error object
   * @returns {Object} - Error response
   */
  handleError(error) {
    let errorType = API_ERRORS.UNKNOWN_ERROR;
    let errorMessage = 'An unexpected error occurred';
    
    if (error.name === 'AbortError') {
      errorType = API_ERRORS.TIMEOUT_ERROR;
      errorMessage = 'Request timeout. Please try again.';
    } else if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
      errorType = API_ERRORS.NETWORK_ERROR;
      errorMessage = 'Network error. Please check your connection.';
    }
    
    return {
      success: false,
      error: {
        type: errorType,
        message: errorMessage,
        originalError: error,
        timestamp: new Date().toISOString()
      }
    };
  }
  
  /**
   * Get error type from status code
   * @param {number} status - HTTP status code
   * @returns {string} - Error type
   */
  getErrorType(status) {
    if (status === 401 || status === 403) {
      return API_ERRORS.AUTH_ERROR;
    } else if (status === 422) {
      return API_ERRORS.VALIDATION_ERROR;
    } else if (status >= 500) {
      return API_ERRORS.SERVER_ERROR;
    } else {
      return API_ERRORS.UNKNOWN_ERROR;
    }
  }
  
  /**
   * GET request
   * @param {string} url - Request URL
   * @param {Object} params - Query parameters
   * @param {Object} options - Additional options
   * @returns {Promise} - Response promise
   */
  async get(url, params = {}, options = {}) {
    const queryString = new URLSearchParams(params).toString();
    const fullUrl = queryString ? `${url}?${queryString}` : url;
    
    return this.request(fullUrl, {
      method: HTTP_METHODS.GET,
      ...options
    });
  }
  
  /**
   * POST request
   * @param {string} url - Request URL
   * @param {Object} data - Request data
   * @param {Object} options - Additional options
   * @returns {Promise} - Response promise
   */
  async post(url, data = {}, options = {}) {
    return this.request(url, {
      method: HTTP_METHODS.POST,
      body: JSON.stringify(data),
      ...options
    });
  }
  
  /**
   * PUT request
   * @param {string} url - Request URL
   * @param {Object} data - Request data
   * @param {Object} options - Additional options
   * @returns {Promise} - Response promise
   */
  async put(url, data = {}, options = {}) {
    return this.request(url, {
      method: HTTP_METHODS.PUT,
      body: JSON.stringify(data),
      ...options
    });
  }
  
  /**
   * PATCH request
   * @param {string} url - Request URL
   * @param {Object} data - Request data
   * @param {Object} options - Additional options
   * @returns {Promise} - Response promise
   */
  async patch(url, data = {}, options = {}) {
    return this.request(url, {
      method: HTTP_METHODS.PATCH,
      body: JSON.stringify(data),
      ...options
    });
  }
  
  /**
   * DELETE request
   * @param {string} url - Request URL
   * @param {Object} options - Additional options
   * @returns {Promise} - Response promise
   */
  async delete(url, options = {}) {
    return this.request(url, {
      method: HTTP_METHODS.DELETE,
      ...options
    });
  }
  
  /**
   * Upload file
   * @param {string} url - Upload URL
   * @param {File} file - File to upload
   * @param {Object} additionalData - Additional form data
   * @param {Function} onProgress - Progress callback
   * @returns {Promise} - Upload promise
   */
  async upload(url, file, additionalData = {}, onProgress = null) {
    const formData = new FormData();
    formData.append('file', file);
    
    Object.keys(additionalData).forEach(key => {
      formData.append(key, additionalData[key]);
    });
    
    const options = {
      method: HTTP_METHODS.POST,
      body: formData,
      headers: {
        'Authorization': this.options.headers['Authorization']
      }
    };
    
    if (onProgress) {
      const xhr = new XMLHttpRequest();
      
      return new Promise((resolve, reject) => {
        xhr.open('POST', `${this.baseURL}${url}`);
        xhr.setRequestHeader('Authorization', options.headers['Authorization']);
        
        xhr.upload.onprogress = (event) => {
          if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100;
            onProgress(percentComplete);
          }
        };
        
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const data = JSON.parse(xhr.responseText);
              resolve({
                success: true,
                data: data.data || data,
                message: data.message
              });
            } catch (e) {
              resolve({
                success: true,
                data: xhr.responseText
              });
            }
          } else {
            reject({
              success: false,
              status: xhr.status,
              message: xhr.statusText
            });
          }
        };
        
        xhr.onerror = () => {
          reject({
            success: false,
            message: 'Network error'
          });
        };
        
        xhr.send(formData);
      });
    }
    
    return this.request(url, options);
  }
  
  /**
   * Download file
   * @param {string} url - Download URL
   * @param {string} filename - Download filename
   * @returns {Promise} - Download promise
   */
  async download(url, filename = 'download') {
    try {
      const response = await fetch(`${this.baseURL}${url}`, {
        headers: {
          'Authorization': this.options.headers['Authorization']
        }
      });
      
      if (!response.ok) {
        throw new Error(`Download failed: ${response.statusText}`);
      }
      
      const blob = await response.blob();
      const downloadUrl = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(downloadUrl);
      document.body.removeChild(a);
      
      return {
        success: true,
        message: 'Download started'
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Search endpoint
   * @param {Object} params - Search parameters
   * @returns {Promise} - Search results
   */
  async search(params) {
    return this.get(API_ENDPOINTS.JOBS.SEARCH, params);
  }
  
  /**
   * Login user
   * @param {Object} credentials - Login credentials
   * @returns {Promise} - Login response
   */
  async login(credentials) {
    const response = await this.post(API_ENDPOINTS.AUTH.LOGIN, credentials);
    
    if (response.success && response.data.token) {
      this.setAuthToken(response.data.token);
      localStorage.setItem('authToken', response.data.token);
      localStorage.setItem('user', JSON.stringify(response.data.user));
    }
    
    return response;
  }
  
  /**
   * Register user
   * @param {Object} userData - User registration data
   * @returns {Promise} - Registration response
   */
  async register(userData) {
    return this.post(API_ENDPOINTS.AUTH.REGISTER, userData);
  }
  
  /**
   * Logout user
   * @returns {Promise} - Logout response
   */
  async logout() {
    const response = await this.post(API_ENDPOINTS.AUTH.LOGOUT);
    
    if (response.success) {
      this.authToken = null;
      delete this.options.headers['Authorization'];
      localStorage.removeItem('authToken');
      localStorage.removeItem('user');
    }
    
    return response;
  }
  
  /**
   * Refresh token
   * @returns {Promise} - Refresh response
   */
  async refreshToken() {
    const response = await this.post(API_ENDPOINTS.AUTH.REFRESH);
    
    if (response.success && response.data.token) {
      this.setAuthToken(response.data.token);
      localStorage.setItem('authToken', response.data.token);
    }
    
    return response;
  }
  
  /**
   * Get user profile
   * @returns {Promise} - Profile response
   */
  async getProfile() {
    return this.get(API_ENDPOINTS.USERS.PROFILE);
  }
  
  /**
   * Update user profile
   * @param {Object} profileData - Profile data
   * @returns {Promise} - Update response
   */
  async updateProfile(profileData) {
    return this.put(API_ENDPOINTS.USERS.UPDATE, profileData);
  }
  
  /**
   * Upload user avatar
   * @param {File} file - Avatar image file
   * @param {Function} onProgress - Upload progress callback
   * @returns {Promise} - Upload response
   */
  async uploadAvatar(file, onProgress = null) {
    return this.upload(API_ENDPOINTS.USERS.UPLOAD_AVATAR, file, {}, onProgress);
  }
  
  /**
   * Get jobs list
   * @param {Object} filters - Job filters
   * @returns {Promise} - Jobs response
   */
  async getJobs(filters = {}) {
    return this.get(API_ENDPOINTS.JOBS.LIST, filters);
  }
  
  /**
   * Get job details
   * @param {string} jobId - Job ID
   * @returns {Promise} - Job response
   */
  async getJob(jobId) {
    const url = API_ENDPOINTS.JOBS.GET.replace(':id', jobId);
    return this.get(url);
  }
  
  /**
   * Apply for a job
   * @param {string} jobId - Job ID
   * @param {Object} applicationData - Application data
   * @returns {Promise} - Application response
   */
  async applyForJob(jobId, applicationData = {}) {
    const url = API_ENDPOINTS.JOBS.APPLY.replace(':id', jobId);
    return this.post(url, applicationData);
  }
  
  /**
   * Save a job
   * @param {string} jobId - Job ID
   * @returns {Promise} - Save response
   */
  async saveJob(jobId) {
    const url = API_ENDPOINTS.JOBS.SAVE.replace(':id', jobId);
    return this.post(url);
  }
  
  /**
   * Get job applications
   * @param {Object} filters - Application filters
   * @returns {Promise} - Applications response
   */
  async getApplications(filters = {}) {
    return this.get(API_ENDPOINTS.APPLICATIONS.LIST, filters);
  }
  
  /**
   * Initiate payment
   * @param {Object} paymentData - Payment data
   * @returns {Promise} - Payment response
   */
  async initiatePayment(paymentData) {
    return this.post(API_ENDPOINTS.PAYMENTS.INITIATE, paymentData);
  }
  
  /**
   * Verify payment
   * @param {string} paymentId - Payment ID
   * @returns {Promise} - Verification response
   */
  async verifyPayment(paymentId) {
    const url = API_ENDPOINTS.PAYMENTS.VERIFY;
    return this.post(url, { payment_id: paymentId });
  }
  
  /**
   * Get payment history
   * @param {Object} filters - History filters
   * @returns {Promise} - History response
   */
  async getPaymentHistory(filters = {}) {
    return this.get(API_ENDPOINTS.PAYMENTS.HISTORY, filters);
  }
  
  /**
   * Get notifications
   * @param {Object} filters - Notification filters
   * @returns {Promise} - Notifications response
   */
  async getNotifications(filters = {}) {
    return this.get(API_ENDPOINTS.NOTIFICATIONS.LIST, filters);
  }
  
  /**
   * Mark notification as read
   * @param {string} notificationId - Notification ID
   * @returns {Promise} - Mark read response
   */
  async markNotificationAsRead(notificationId) {
    const url = API_ENDPOINTS.NOTIFICATIONS.MARK_READ.replace(':id', notificationId);
    return this.post(url);
  }
  
  /**
   * Mark all notifications as read
   * @returns {Promise} - Mark all read response
   */
  async markAllNotificationsAsRead() {
    return this.post(API_ENDPOINTS.NOTIFICATIONS.MARK_ALL_READ);
  }
  
  /**
   * Send message
   * @param {Object} messageData - Message data
   * @returns {Promise} - Message response
   */
  async sendMessage(messageData) {
    return this.post(API_ENDPOINTS.MESSAGES.SEND, messageData);
  }
  
  /**
   * Get messages
   * @param {Object} filters - Message filters
   * @returns {Promise} - Messages response
   */
  async getMessages(filters = {}) {
    return this.get(API_ENDPOINTS.MESSAGES.LIST, filters);
  }
  
  /**
   * AI Chat
   * @param {string} message - Chat message
   * @param {Object} options - Chat options
   * @returns {Promise} - Chat response
   */
  async chatWithAI(message, options = {}) {
    return this.post(API_ENDPOINTS.AI_CHAT.CHAT, {
      message,
      ...options
    });
  }
  
  /**
   * Get AI chat history
   * @returns {Promise} - Chat history
   */
  async getChatHistory() {
    return this.get(API_ENDPOINTS.AI_CHAT.HISTORY);
  }
  
  /**
   * Clear AI chat history
   * @returns {Promise} - Clear response
   */
  async clearChatHistory() {
    return this.post(API_ENDPOINTS.AI_CHAT.CLEAR);
  }
  
  /**
   * Get analytics dashboard data
   * @returns {Promise} - Analytics response
   */
  async getAnalytics() {
    return this.get(API_ENDPOINTS.ANALYTICS.DASHBOARD);
  }
  
  /**
   * Get user settings
   * @returns {Promise} - Settings response
   */
  async getSettings() {
    return this.get(API_ENDPOINTS.SETTINGS.GET);
  }
  
  /**
   * Update user settings
   * @param {Object} settingsData - Settings data
   * @returns {Promise} - Update response
   */
  async updateSettings(settingsData) {
    return this.put(API_ENDPOINTS.SETTINGS.UPDATE, settingsData);
  }
}

// Create default API client instance
export const apiClient = new ApiClient(process.env.API_BASE_URL || 'https://api.zewedjobs.com/v1');

// Export for global use
export default apiClient;
EOF
echo "‚úÖ Created: js/api.js"

# File 3: translator.js
cat > js/translator.js << 'EOF'
/**
 * translator.js - Translation and localization module for Zewed Jobs
 * @version 1.0.0
 * Supports: English (en), Amharic (am), Oromiffa (om), Tigrinya (ti)
 */

// Available languages
export const LANGUAGES = {
  en: {
    name: 'English',
    nativeName: 'English',
    direction: 'ltr',
    flag: 'üá∫üá∏'
  },
  am: {
    name: 'Amharic',
    nativeName: '·ä†·àõ·à≠·äõ',
    direction: 'ltr',
    flag: 'üá™üáπ'
  },
  om: {
    name: 'Oromiffa',
    nativeName: 'Afaan Oromoo',
    direction: 'ltr',
    flag: 'üá™üáπ'
  },
  ti: {
    name: 'Tigrinya',
    nativeName: '·âµ·åç·à≠·äõ',
    direction: 'ltr',
    flag: 'üá™üáπ'
  }
};

// Default translations
const DEFAULT_TRANSLATIONS = {
  en: {
    // Common
    'common.save': 'Save',
    'common.cancel': 'Cancel',
    'common.edit': 'Edit',
    'common.delete': 'Delete',
    'common.confirm': 'Confirm',
    'common.loading': 'Loading...',
    'common.error': 'Error',
    'common.success': 'Success',
    'common.warning': 'Warning',
    'common.info': 'Info',
    'common.retry': 'Retry',
    'common.back': 'Back',
    'common.next': 'Next',
    'common.submit': 'Submit',
    'common.search': 'Search',
    'common.filter': 'Filter',
    'common.sort': 'Sort',
    'common.view': 'View',
    'common.download': 'Download',
    'common.upload': 'Upload',
    'common.select': 'Select',
    'common.all': 'All',
    'common.none': 'None',
    'common.apply': 'Apply',
    'common.clear': 'Clear',
    'common.close': 'Close',
    'common.open': 'Open',
    'common.yes': 'Yes',
    'common.no': 'No',
    'common.ok': 'OK',
    
    // Navigation
    'nav.home': 'Home',
    'nav.jobs': 'Jobs',
    'nav.companies': 'Companies',
    'nav.candidates': 'Candidates',
    'nav.blog': 'Blog',
    'nav.about': 'About',
    'nav.contact': 'Contact',
    'nav.dashboard': 'Dashboard',
    'nav.profile': 'Profile',
    'nav.settings': 'Settings',
    'nav.logout': 'Logout',
    'nav.login': 'Login',
    'nav.register': 'Register',
    'nav.notifications': 'Notifications',
    'nav.messages': 'Messages',
    'nav.payments': 'Payments',
    'nav.applications': 'Applications',
    'nav.saved_jobs': 'Saved Jobs',
    'nav.ai_assistant': 'AI Assistant',
    
    // Auth
    'auth.login': 'Login',
    'auth.register': 'Register',
    'auth.email': 'Email Address',
    'auth.password': 'Password',
    'auth.confirm_password': 'Confirm Password',
    'auth.forgot_password': 'Forgot Password?',
    'auth.remember_me': 'Remember Me',
    'auth.no_account': 'Don\'t have an account?',
    'auth.has_account': 'Already have an account?',
    'auth.login_success': 'Logged in successfully',
    'auth.register_success': 'Account created successfully',
    'auth.logout_success': 'Logged out successfully',
    'auth.invalid_credentials': 'Invalid email or password',
    'auth.email_exists': 'Email already exists',
    'auth.password_requirements': 'Password must be at least 8 characters',
    'auth.passwords_mismatch': 'Passwords do not match',
    
    // Jobs
    'jobs.title': 'Jobs',
    'jobs.find': 'Find Your Dream Job',
    'jobs.search_placeholder': 'Job title, keyword, or company',
    'jobs.location_placeholder': 'City, region, or remote',
    'jobs.category': 'Category',
    'jobs.type': 'Type',
    'jobs.salary': 'Salary',
    'jobs.experience': 'Experience',
    'jobs.posted': 'Posted',
    'jobs.deadline': 'Application Deadline',
    'jobs.apply': 'Apply Now',
    'jobs.save': 'Save Job',
    'jobs.saved': 'Saved',
    'jobs.unsave': 'Unsave',
    'jobs.applied': 'Applied',
    'jobs.view_details': 'View Details',
    'jobs.description': 'Description',
    'jobs.requirements': 'Requirements',
    'jobs.responsibilities': 'Responsibilities',
    'jobs.benefits': 'Benefits',
    'jobs.company': 'Company',
    'jobs.location': 'Location',
    'jobs.remote': 'Remote',
    'jobs.onsite': 'On-site',
    'jobs.hybrid': 'Hybrid',
    'jobs.full_time': 'Full-time',
    'jobs.part_time': 'Part-time',
    'jobs.contract': 'Contract',
    'jobs.internship': 'Internship',
    'jobs.freelance': 'Freelance',
    'jobs.no_jobs': 'No jobs found',
    'jobs.load_more': 'Load More Jobs',
    
    // Applications
    'applications.title': 'Applications',
    'applications.status': 'Status',
    'applications.applied_date': 'Applied Date',
    'applications.cover_letter': 'Cover Letter',
    'applications.resume': 'Resume',
    'applications.withdraw': 'Withdraw Application',
    'applications.withdraw_confirm': 'Are you sure you want to withdraw your application?',
    'applications.status_pending': 'Pending',
    'applications.status_reviewed': 'Under Review',
    'applications.status_shortlisted': 'Shortlisted',
    'applications.status_interview': 'Interview',
    'applications.status_offered': 'Offer',
    'applications.status_rejected': 'Rejected',
    'applications.status_accepted': 'Accepted',
    'applications.no_applications': 'No applications yet',
    
    // Payments
    'payments.title': 'Payments',
    'payments.make_payment': 'Make Payment',
    'payments.history': 'Payment History',
    'payments.amount': 'Amount',
    'payments.currency': 'Currency',
    'payments.method': 'Payment Method',
    'payments.status': 'Status',
    'payments.date': 'Date',
    'payments.transaction_id': 'Transaction ID',
    'payments.invoice': 'Invoice',
    'payments.receipt': 'Receipt',
    'payments.pay_now': 'Pay Now',
    'payments.choose_method': 'Choose Payment Method',
    'payments.credit_card': 'Credit Card',
    'payments.mobile_money': 'Mobile Money',
    'payments.bank_transfer': 'Bank Transfer',
    'payments.paypal': 'PayPal',
    'payments.card_number': 'Card Number',
    'payments.card_expiry': 'Expiry Date',
    'payments.card_cvv': 'CVV',
    'payments.card_name': 'Name on Card',
    'payments.phone_number': 'Phone Number',
    'payments.provider': 'Provider',
    'payments.bank_name': 'Bank Name',
    'payments.account_number': 'Account Number',
    'payments.status_pending': 'Pending',
    'payments.status_processing': 'Processing',
    'payments.status_completed': 'Completed',
    'payments.status_failed': 'Failed',
    'payments.status_refunded': 'Refunded',
    'payments.security_note': 'Your payment information is secure and encrypted',
    
    // Profile
    'profile.title': 'Profile',
    'profile.edit': 'Edit Profile',
    'profile.name': 'Full Name',
    'profile.email': 'Email',
    'profile.phone': 'Phone Number',
    'profile.location': 'Location',
    'profile.bio': 'Bio',
    'profile.skills': 'Skills',
    'profile.experience': 'Experience',
    'profile.education': 'Education',
    'profile.languages': 'Languages',
    'profile.save_changes': 'Save Changes',
    'profile.upload_photo': 'Upload Photo',
    'profile.change_password': 'Change Password',
    'profile.current_password': 'Current Password',
    'profile.new_password': 'New Password',
    'profile.confirm_new_password': 'Confirm New Password',
    'profile.password_updated': 'Password updated successfully',
    
    // Notifications
    'notifications.title': 'Notifications',
    'notifications.mark_all_read': 'Mark all as read',
    'notifications.clear_all': 'Clear all',
    'notifications.no_notifications': 'No notifications',
    'notifications.new_message': 'New message from {name}',
    'notifications.job_alert': 'New job matching your criteria: {title}',
    'notifications.application_update': 'Your application for {job} has been {status}',
    'notifications.payment_success': 'Payment of {amount} completed successfully',
    'notifications.payment_failed': 'Payment of {amount} failed',
    
    // Messages
    'messages.title': 'Messages',
    'messages.send': 'Send Message',
    'messages.type_message': 'Type your message...',
    'messages.no_messages': 'No messages yet',
    'messages.no_conversations': 'No conversations',
    'messages.new_conversation': 'New Conversation',
    'messages.select_contact': 'Select a contact to start chatting',
    
    // AI Assistant
    'ai.title': 'AI Assistant',
    'ai.placeholder': 'Ask me anything about jobs, applications, or career advice...',
    'ai.thinking': 'Thinking...',
    'ai.suggestions': 'Try asking:',
    'ai.suggestion1': 'Help me write a cover letter',
    'ai.suggestion2': 'What are the latest job trends?',
    'ai.suggestion3': 'How to prepare for a job interview?',
    'ai.suggestion4': 'Review my resume',
    'ai.clear_chat': 'Clear Chat',
    'ai.error': 'Sorry, I encountered an error. Please try again.',
    
    // Settings
    'settings.title': 'Settings',
    'settings.general': 'General',
    'settings.notifications': 'Notifications',
    'settings.privacy': 'Privacy',
    'settings.security': 'Security',
    'settings.language': 'Language',
    'settings.theme': 'Theme',
    'settings.currency': 'Currency',
    'settings.email_notifications': 'Email Notifications',
    'settings.push_notifications': 'Push Notifications',
    'settings.job_alerts': 'Job Alerts',
    'settings.message_notifications': 'Message Notifications',
    'settings.payment_notifications': 'Payment Notifications',
    'settings.two_factor_auth': 'Two-Factor Authentication',
    'settings.data_privacy': 'Data Privacy',
    'settings.delete_account': 'Delete Account',
    'settings.delete_warning': 'This action cannot be undone. All your data will be permanently deleted.',
    
    // Errors
    'error.network': 'Network error. Please check your connection.',
    'error.timeout': 'Request timeout. Please try again.',
    'error.server': 'Server error. Please try again later.',
    'error.unauthorized': 'You need to login to access this page.',
    'error.forbidden': 'You don\'t have permission to access this page.',
    'error.not_found': 'The requested resource was not found.',
    'error.validation': 'Please check your input and try again.',
    'error.unknown': 'An unexpected error occurred.',
    
    // Success Messages
    'success.saved': 'Saved successfully',
    'success.updated': 'Updated successfully',
    'success.deleted': 'Deleted successfully',
    'success.applied': 'Applied successfully',
    'success.payment': 'Payment completed successfully',
    'success.message_sent': 'Message sent successfully',
    
    // Welcome
    'welcome.title': 'Welcome to Zewed Jobs',
    'welcome.message': 'Your career journey starts here',
    
    // Language
    'language.switched': 'Language switched',
    'language.switched_message': 'Language has been changed to {language}',
    
    // Ethiopian Specific
    'ethiopian.regions': 'Regions',
    'ethiopian.addis_ababa': 'Addis Ababa',
    'ethiopian.afar': 'Afar',
    'ethiopian.amhara': 'Amhara',
    'ethiopian.benishangul': 'Benishangul-Gumuz',
    'ethiopian.dire_dawa': 'Dire Dawa',
    'ethiopian.gambela': 'Gambela',
    'ethiopian.harari': 'Harari',
    'ethiopian.oromia': 'Oromia',
    'ethiopian.sidama': 'Sidama',
    'ethiopian.somali': 'Somali',
    'ethiopian.south_west': 'South West Ethiopia',
    'ethiopian.tigray': 'Tigray',
    'ethiopian.currency': 'Ethiopian Birr',
    'ethiopian.date_format': 'DD/MM/YYYY',
    
    // Time
    'time.just_now': 'Just now',
    'time.minutes_ago': '{count} minutes ago',
    'time.hours_ago': '{count} hours ago',
    'time.days_ago': '{count} days ago',
    'time.weeks_ago': '{count} weeks ago',
    'time.months_ago': '{count} months ago',
    'time.years_ago': '{count} years ago',
  },
  
  am: {
    // Common
    'common.save': '·ä†·àµ·âÄ·àù·å•',
    'common.cancel': '·à∞·à≠·ãù',
    'common.edit': '·ä†·à≠·âµ·ãï',
    'common.delete': '·à∞·à≠·ãù',
    'common.confirm': '·ä†·à®·åã·åç·å•',
    'common.loading': '·â†·àò·å´·äï ·àã·ã≠...',
    'common.error': '·àµ·àÖ·â∞·âµ',
    'common.success': '·â∞·à≥·ä≠·â∑·àç',
    'common.warning': '·àõ·àµ·å†·äï·âÄ·âÇ·ã´',
    'common.info': '·àò·à®·åÉ',
    'common.retry': '·ä•·äï·ã∞·åà·äì ·àû·ä≠·à≠',
    'common.back': '·â∞·àò·àà·àµ',
    'common.next': '·âÄ·å•·àç',
    'common.submit': '·ä†·àµ·åà·â£',
    'common.search': '·çà·àç·åç',
    'common.filter': '·ä†·å£·à´',
    'common.sort': '·àõ·ã∞·à´·åÉ',
    'common.view': '·â∞·àò·àç·ä®·âµ',
    'common.download': '·ä†·ãç·à≠·ãµ',
    'common.upload': '·å´·äï',
    'common.select': '·àù·à®·å•',
    'common.all': '·àÅ·àâ·àù',
    'common.none': '·àù·äï·àù',
    'common.apply': '·ä†·àò·àç·ä≠·âµ',
    'common.clear': '·ä†·åΩ·ã≥',
    'common.close': '·ãù·åã',
    'common.open': '·ä≠·çà·âµ',
    'common.yes': '·ä†·ãé',
    'common.no': '·ä†·ã≠',
    'common.ok': '·ä•·à∫',
    
    // Navigation
    'nav.home': '·àò·äê·àª',
    'nav.jobs': '·àµ·à´·ãé·âΩ',
    'nav.companies': '·ä©·â£·äï·ã´·ãé·âΩ',
    'nav.candidates': '·ä†·àò·àç·ä´·âæ·âΩ',
    'nav.blog': '·â•·àé·åç',
    'nav.about': '·àµ·àà·äõ',
    'nav.contact': '·ä†·åç·äù·äï',
    'nav.dashboard': '·ã≥·àΩ·â¶·à≠·ãµ',
    'nav.profile': '·àò·åà·àà·å´',
    'nav.settings': '·âÖ·äï·â•·àÆ·âΩ',
    'nav.logout': '·ãç·å£',
    'nav.login': '·åç·â£',
    'nav.register': '·ã≠·àò·ãù·åà·â°',
    'nav.notifications': '·àõ·àµ·â≥·ãà·âÇ·ã´·ãé·âΩ',
    'nav.messages': '·àò·àç·ãï·ä≠·â∂·âΩ',
    'nav.payments': '·ä≠·çç·ã´·ãé·âΩ',
    'nav.applications': '·ã®·àò·å†·âÜ·àö·ã´·ãé·âΩ',
    'nav.saved_jobs': '·ã®·â∞·âÄ·àò·å° ·àµ·à´·ãé·âΩ',
    'nav.ai_assistant': 'AI ·à®·ã≥·âµ',
    
    // Auth
    'auth.login': '·åç·â£',
    'auth.register': '·ã≠·àò·ãù·åà·â°',
    'auth.email': '·ä¢·àú·ã≠·àç',
    'auth.password': '·ã®·ã≠·àà·çç ·âÉ·àç',
    'auth.confirm_password': '·ã®·ã≠·àà·çç ·âÉ·àç ·ä†·à®·åã·åç·å•',
    'auth.forgot_password': '·ã®·ã≠·àà·çç ·âÉ·àç ·à®·à≥·àÅ?',
    'auth.remember_me': '·ä†·àµ·â≥·ãç·à∞·äù',
    'auth.no_account': '·àò·àà·ã´ ·ã®·àé·âµ·àù?',
    'auth.has_account': '·ä†·àµ·âÄ·ãµ·àû ·àò·àà·ã´ ·ä†·àà·ãé·âµ?',
    'auth.login_success': '·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·åà·â•·â∞·ãã·àç',
    'auth.register_success': '·àò·àà·ã´ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·çà·å•·àØ·àç',
    'auth.logout_success': '·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·ãà·å•·â∞·ãã·àç',
    'auth.invalid_credentials': '·àç·ä≠ ·ã´·àç·àÜ·äê ·ä¢·àú·ã≠·àç ·ãà·ã≠·àù ·ã®·ã≠·àà·çç ·âÉ·àç',
    'auth.email_exists': '·ä¢·àú·ã≠·àç ·ä†·àµ·âÄ·ãµ·àû ·ä†·àà',
    'auth.password_requirements': '·ã®·ã≠·àà·çç ·âÉ·àç ·â¢·ã´·äï·àµ 8 ·âÅ·àù·çä ·àä·äñ·à®·ãç ·ã≠·åà·â£·àç',
    'auth.passwords_mismatch': '·ã®·ã≠·àà·çç ·âÉ·àé·âΩ ·ä†·ã≠·àò·à≥·à∞·àâ·àù',
    
    // Jobs
    'jobs.title': '·àµ·à´·ãé·âΩ',
    'jobs.find': '·ã®·àï·àç·àù·àÖ·äï ·àµ·à´ ·çà·àç·åç',
    'jobs.search_placeholder': '·ã®·àµ·à´ ·àò·àà·ã´·ç£ ·âÅ·àç·çç ·âÉ·àç·ç£ ·ãà·ã≠·àù ·ä©·â£·äï·ã´',
    'jobs.location_placeholder': '·ä®·â∞·àõ·ç£ ·ä≠·àç·àç·ç£ ·ãà·ã≠·àù ·à©·âÖ',
    'jobs.category': '·ä≠·çç·àç',
    'jobs.type': '·ãì·ã≠·äê·âµ',
    'jobs.salary': '·ã∞·àò·ãà·ãù',
    'jobs.experience': '·â∞·àû·ä≠·àÆ',
    'jobs.posted': '·â∞·àà·å†·çà',
    'jobs.deadline': '·ã®·àò·å†·âÜ·àö·ã´ ·åä·ãú',
    'jobs.apply': '·ä†·àò·àç·ä≠·âµ',
    'jobs.save': '·àµ·à´·ãç·äï ·ä†·àµ·âÄ·àù·å•',
    'jobs.saved': '·â∞·âÄ·àù·åß·àç',
    'jobs.unsave': '·ä†·àã·àµ·âÄ·àù·å•·àù',
    'jobs.applied': '·â∞·àò·ãù·åç·â†·ãã·àç',
    'jobs.view_details': '·ãù·à≠·ãù·àÆ·âΩ·äï ·â∞·àò·àç·ä®·âµ',
    'jobs.description': '·àò·åç·àà·å´',
    'jobs.requirements': '·àõ·àµ·çà·àã·åä·ã´·ãé·âΩ',
    'jobs.responsibilities': '·äÉ·àã·çä·äê·â∂·âΩ',
    'jobs.benefits': '·å•·âÖ·àû·âΩ',
    'jobs.company': '·ä©·â£·äï·ã´',
    'jobs.location': '·â¶·â≥',
    'jobs.remote': '·à©·âÖ',
    'jobs.onsite': '·â†·â¶·â≥',
    'jobs.hybrid': '·â∞·ã∞·â£·àà·âÄ',
    'jobs.full_time': '·àô·àâ ·åä·ãú',
    'jobs.part_time': '·ä®·çä·àç ·åä·ãú',
    'jobs.contract': '·äÆ·äï·âµ·à´·âµ',
    'jobs.internship': '·âµ·àù·àÖ·à≠·âµ ·à•·à´',
    'jobs.freelance': '·çç·à™·àã·äï·àµ',
    'jobs.no_jobs': '·àù·äï·àù ·àµ·à´ ·ä†·àç·â∞·åà·äò·àù',
    'jobs.load_more': '·â∞·å®·àõ·à™ ·àµ·à´·ãé·âΩ·äï ·å´·äï',
  }
};

/**
 * Translator class for handling multi-language support
 */
export class Translator {
  constructor(defaultLang = 'en') {
    this.currentLang = defaultLang;
    this.translations = DEFAULT_TRANSLATIONS;
    this.fallbackLang = 'en';
    this.loadedLanguages = new Set([defaultLang]);
    this.init();
  }
  
  /**
   * Initialize translator
   */
  init() {
    // Set HTML lang attribute
    document.documentElement.lang = this.currentLang;
    
    // Set text direction
    const direction = LANGUAGES[this.currentLang]?.direction || 'ltr';
    document.documentElement.dir = direction;
    
    // Load language from localStorage
    const savedLang = localStorage.getItem('language');
    if (savedLang && this.isLanguageSupported(savedLang)) {
      this.setLanguage(savedLang, false);
    }
    
    // Load external translations if needed
    this.loadExternalTranslations();
  }
  
  /**
   * Check if language is supported
   * @param {string} lang - Language code
   * @returns {boolean} - True if supported
   */
  isLanguageSupported(lang) {
    return lang in LANGUAGES;
  }
  
  /**
   * Get available languages
   * @returns {Object} - Available languages
   */
  getAvailableLanguages() {
    return LANGUAGES;
  }
  
  /**
   * Get current language info
   * @returns {Object} - Current language info
   */
  getCurrentLanguage() {
    return LANGUAGES[this.currentLang] || LANGUAGES[this.fallbackLang];
  }
  
  /**
   * Set language
   * @param {string} lang - Language code
   * @param {boolean} save - Whether to save to localStorage
   */
  setLanguage(lang, save = true) {
    if (!this.isLanguageSupported(lang)) {
      console.warn(`Language "${lang}" is not supported. Falling back to "${this.fallbackLang}"`);
      lang = this.fallbackLang;
    }
    
    this.currentLang = lang;
    
    // Update HTML attributes
    document.documentElement.lang = lang;
    const direction = LANGUAGES[lang]?.direction || 'ltr';
    document.documentElement.dir = direction;
    
    // Save to localStorage
    if (save) {
      localStorage.setItem('language', lang);
    }
    
    // Load language if not already loaded
    if (!this.loadedLanguages.has(lang)) {
      this.loadLanguage(lang);
    }
    
    // Translate page
    this.translatePage();
  }
  
  /**
   * Load language translations
   * @param {string} lang - Language code
   * @returns {Promise} - Loading promise
   */
  async loadLanguage(lang) {
    if (this.loadedLanguages.has(lang)) {
      return Promise.resolve();
    }
    
    try {
      // Try to load external translation file
      const response = await fetch(`/translations/${lang}.json`);
      
      if (response.ok) {
        const externalTranslations = await response.json();
        this.translations[lang] = {
          ...this.translations[lang],
          ...externalTranslations
        };
      }
      
      this.loadedLanguages.add(lang);
      console.log(`‚úÖ Loaded translations for ${lang}`);
      
    } catch (error) {
      console.warn(`Could not load external translations for ${lang}:`, error);
      
      // Use default translations
      if (!this.translations[lang]) {
        this.translations[lang] = {};
      }
      
      this.loadedLanguages.add(lang);
    }
  }
  
  /**
   * Load external translations
   */
  async loadExternalTranslations() {
    const languages = Object.keys(LANGUAGES);
    
    for (const lang of languages) {
      if (lang !== this.fallbackLang) {
        await this.loadLanguage(lang);
      }
    }
  }
  
  /**
   * Get translation
   * @param {string} key - Translation key
   * @param {Object} params - Parameters to replace
   * @returns {string} - Translated text
   */
  translate(key, params = {}) {
    let translation = this.getTranslation(key);
    
    // Replace parameters
    if (translation && params) {
      Object.keys(params).forEach(param => {
        translation = translation.replace(new RegExp(`{${param}}`, 'g'), params[param]);
      });
    }
    
    return translation || key;
  }
  
  /**
   * Get translation from current or fallback language
   * @param {string} key - Translation key
   * @returns {string} - Translated text
   */
  getTranslation(key) {
    // Try current language
    if (this.translations[this.currentLang] && this.translations[this.currentLang][key]) {
      return this.translations[this.currentLang][key];
    }
    
    // Try fallback language
    if (this.translations[this.fallbackLang] && this.translations[this.fallbackLang][key]) {
      return this.translations[this.fallbackLang][key];
    }
    
    // Return key if not found
    return null;
  }
  
  /**
   * Translate entire page
   */
  translatePage() {
    // Translate data-i18n elements
    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      const translation = this.translate(key);
      
      if (translation && translation !== key) {
        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
          element.placeholder = translation;
        } else {
          element.textContent = translation;
        }
      }
    });
    
    // Translate data-i18n-attr elements
    document.querySelectorAll('[data-i18n-attr]').forEach(element => {
      const attrData = element.getAttribute('data-i18n-attr');
      const [attr, key] = attrData.split(':');
      
      if (attr && key) {
        const translation = this.translate(key);
        
        if (translation && translation !== key) {
          element.setAttribute(attr, translation);
        }
      }
    });
    
    // Translate data-i18n-title elements
    document.querySelectorAll('[data-i18n-title]').forEach(element => {
      const key = element.getAttribute('data-i18n-title');
      const translation = this.translate(key);
      
      if (translation && translation !== key) {
        element.title = translation;
      }
    });
    
    // Update language switcher
    this.updateLanguageSwitcher();
    
    // Trigger translation event
    this.triggerTranslationEvent();
  }
  
  /**
   * Update language switcher UI
   */
  updateLanguageSwitcher() {
    const switchers = document.querySelectorAll('.language-switcher');
    
    switchers.forEach(switcher => {
      const buttons = switcher.querySelectorAll('[data-lang]');
      
      buttons.forEach(button => {
        const lang = button.getAttribute('data-lang');
        const langInfo = LANGUAGES[lang];
        
        if (langInfo) {
          // Update button text
          const textSpan = button.querySelector('.lang-text');
          if (textSpan) {
            textSpan.textContent = lang === this.currentLang ? 
              langInfo.nativeName : langInfo.name;
          }
          
          // Update flag
          const flagSpan = button.querySelector('.lang-flag');
          if (flagSpan) {
            flagSpan.textContent = langInfo.flag;
          }
          
          // Update active state
          button.classList.toggle('active', lang === this.currentLang);
        }
      });
    });
  }
  
  /**
   * Trigger translation event
   */
  triggerTranslationEvent() {
    const event = new CustomEvent('languageChanged', {
      detail: {
        language: this.currentLang,
        languageInfo: LANGUAGES[this.currentLang]
      }
    });
    
    document.dispatchEvent(event);
  }
  
  /**
   * Format number according to locale
   * @param {number} number - Number to format
   * @param {Object} options - Formatting options
   * @returns {string} - Formatted number
   */
  formatNumber(number, options = {}) {
    const locale = this.currentLang === 'en' ? 'en-US' : 'am-ET';
    
    return new Intl.NumberFormat(locale, {
      minimumFractionDigits: 0,
      maximumFractionDigits: 2,
      ...options
    }).format(number);
  }
  
  /**
   * Format currency according to locale
   * @param {number} amount - Amount to format
   * @param {string} currency - Currency code
   * @param {Object} options - Formatting options
   * @returns {string} - Formatted currency
   */
  formatCurrency(amount, currency = 'ETB', options = {}) {
    const locale = this.currentLang === 'en' ? 'en-US' : 'am-ET';
    
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 2,
      ...options
    }).format(amount);
  }
  
  /**
   * Format date according to locale
   * @param {Date|string|number} date - Date to format
   * @param {Object} options - Formatting options
   * @returns {string} - Formatted date
   */
  formatDate(date, options = {}) {
    const locale = this.currentLang === 'en' ? 'en-US' : 'am-ET';
    const dateObj = new Date(date);
    
    const defaultOptions = {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    };
    
    return new Intl.DateTimeFormat(locale, {
      ...defaultOptions,
      ...options
    }).format(dateObj);
  }
  
  /**
   * Format relative time
   * @param {Date|string|number} date - Date to format
   * @returns {string} - Relative time string
   */
  formatRelativeTime(date) {
    const now = new Date();
    const target = new Date(date);
    const diffInSeconds = Math.floor((now - target) / 1000);
    
    if (diffInSeconds < 60) {
      return this.translate('time.just_now');
    }
    
    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return this.translate('time.minutes_ago', { count: diffInMinutes });
    }
    
    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return this.translate('time.hours_ago', { count: diffInHours });
    }
    
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 7) {
      return this.translate('time.days_ago', { count: diffInDays });
    }
    
    const diffInWeeks = Math.floor(diffInDays / 7);
    if (diffInWeeks < 4) {
      return this.translate('time.weeks_ago', { count: diffInWeeks });
    }
    
    const diffInMonths = Math.floor(diffInDays / 30);
    if (diffInMonths < 12) {
      return this.translate('time.months_ago', { count: diffInMonths });
    }
    
    const diffInYears = Math.floor(diffInDays / 365);
    return this.translate('time.years_ago', { count: diffInYears });
  }
  
  /**
   * Switch language
   * @param {string} lang - Language code
   * @returns {Promise} - Switch promise
   */
  async switchLanguage(lang) {
    if (lang === this.currentLang) {
      return;
    }
    
    // Load language if not loaded
    if (!this.loadedLanguages.has(lang)) {
      await this.loadLanguage(lang);
    }
    
    // Set new language
    this.setLanguage(lang);
    
    return Promise.resolve();
  }
  
  /**
   * Add custom translations
   * @param {string} lang - Language code
   * @param {Object} translations - Translations object
   */
  addTranslations(lang, translations) {
    if (!this.translations[lang]) {
      this.translations[lang] = {};
    }
    
    this.translations[lang] = {
      ...this.translations[lang],
      ...translations
    };
    
    // If this is the current language, update the page
    if (lang === this.currentLang) {
      this.translatePage();
    }
  }
  
  /**
   * Get all translations for current language
   * @returns {Object} - Translations object
   */
  getAllTranslations() {
    return this.translations[this.currentLang] || {};
  }
  
  /**
   * Clear translations cache
   */
  clearCache() {
    this.loadedLanguages.clear();
    this.loadedLanguages.add(this.currentLang);
    this.loadedLanguages.add(this.fallbackLang);
  }
}

// Create default translator instance
export const translator = new Translator();

// Export for global use
export default translator;
EOF
echo "‚úÖ Created: js/translator.js"

# File 4: notifications.js
cat > js/notifications.js << 'EOF'
/**
 * notifications.js - Notification system for Zewed Jobs
 * @version 1.0.0
 * Supports: Toast notifications, Push notifications, In-app notifications
 */

// Notification types
export const NOTIFICATION_TYPES = {
  INFO: 'info',
  SUCCESS: 'success',
  WARNING: 'warning',
  ERROR: 'error',
  PAYMENT: 'payment',
  JOB: 'job',
  MESSAGE: 'message',
  SYSTEM: 'system'
};

// Notification positions
export const NOTIFICATION_POSITIONS = {
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right',
  TOP_CENTER: 'top-center',
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  BOTTOM_CENTER: 'bottom-center'
};

// Default configuration
const DEFAULT_CONFIG = {
  position: NOTIFICATION_POSITIONS.TOP_RIGHT,
  duration: 5000,
  maxNotifications: 5,
  showProgress: true,
  pauseOnHover: true,
  closeOnClick: true,
  animateIn: true,
  animateOut: true,
  zIndex: 9999,
  soundEnabled: true,
  vibrationEnabled: false,
  desktopNotifications: false
};

/**
 * Notification Manager class
 */
export class NotificationManager {
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.notifications = new Map();
    this.container = null;
    this.notificationCount = 0;
    this.audioContext = null;
    this.permission = null;
    
    this.init();
  }
  
  /**
   * Initialize notification manager
   */
  init() {
    this.createContainer();
    this.setupEventListeners();
    this.requestPermission();
  }
  
  /**
   * Create notification container
   */
  createContainer() {
    this.container = document.createElement('div');
    this.container.className = 'notifications-container';
    this.container.setAttribute('data-position', this.config.position);
    this.container.style.zIndex = this.config.zIndex;
    
    document.body.appendChild(this.container);
  }
  
  /**
   * Setup event listeners
   */
  setupEventListeners() {
    // Listen for online/offline events
    window.addEventListener('online', () => {
      this.show({
        title: 'You\'re back online',
        message: 'Connection restored',
        type: NOTIFICATION_TYPES.SUCCESS,
        duration: 3000
      });
    });
    
    window.addEventListener('offline', () => {
      this.show({
        title: 'You\'re offline',
        message: 'Some features may be unavailable',
        type: NOTIFICATION_TYPES.WARNING,
        duration: 5000
      });
    });
    
    // Listen for visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.pauseAll();
      } else {
        this.resumeAll();
      }
    });
    
    // Listen for storage events (cross-tab notifications)
    window.addEventListener('storage', (event) => {
      if (event.key === 'zewed-notification') {
        try {
          const notification = JSON.parse(event.newValue);
          if (notification) {
            this.show(notification);
          }
        } catch (error) {
          console.error('Failed to parse storage notification:', error);
        }
      }
    });
  }
  
  /**
   * Request notification permission
   */
  async requestPermission() {
    if ('Notification' in window) {
      try {
        this.permission = await Notification.requestPermission();
        
        if (this.permission === 'granted' && this.config.desktopNotifications) {
          this.show({
            title: 'Notifications enabled',
            message: 'You\'ll now receive desktop notifications',
            type: NOTIFICATION_TYPES.SUCCESS,
            duration: 3000
          });
        }
      } catch (error) {
        console.error('Failed to request notification permission:', error);
      }
    }
  }
  
  /**
   * Show a notification
   * @param {Object} options - Notification options
   * @returns {string} - Notification ID
   */
  show(options) {
    // Default options
    const notificationOptions = {
      id: `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title: '',
      message: '',
      type: NOTIFICATION_TYPES.INFO,
      duration: this.config.duration,
      position: this.config.position,
      icon: null,
      image: null,
      actions: [],
      sound: true,
      vibration: this.config.vibrationEnabled,
      desktop: this.config.desktopNotifications,
      data: {},
      onClose: null,
      onClick: null,
      onAction: null,
      ...options
    };
    
    // Create notification element
    const notificationElement = this.createNotificationElement(notificationOptions);
    
    // Add to container
    this.container.appendChild(notificationElement);
    
    // Store notification
    this.notifications.set(notificationOptions.id, {
      element: notificationElement,
      options: notificationOptions,
      timeout: null,
      progress: 0,
      startTime: Date.now(),
      paused: false
    });
    
    // Start timer
    this.startTimer(notificationOptions.id);
    
    // Play sound
    if (notificationOptions.sound && this.config.soundEnabled) {
      this.playSound(notificationOptions.type);
    }
    
    // Vibrate
    if (notificationOptions.vibration && 'vibrate' in navigator) {
      navigator.vibrate(200);
    }
    
    // Show desktop notification
    if (notificationOptions.desktop && this.permission === 'granted') {
      this.showDesktopNotification(notificationOptions);
    }
    
    // Limit number of notifications
    this.limitNotifications();
    
    // Animate in
    if (this.config.animateIn) {
      setTimeout(() => {
        notificationElement.classList.add('show');
      }, 10);
    }
    
    // Update notification count
    this.updateNotificationCount();
    
    return notificationOptions.id;
  }
  
  /**
   * Create notification element
   * @param {Object} options - Notification options
   * @returns {HTMLElement} - Notification element
   */
  createNotificationElement(options) {
    const notification = document.createElement('div');
    notification.className = `notification notification-${options.type}`;
    notification.setAttribute('data-id', options.id);
    
    // Icon
    const icon = this.getNotificationIcon(options.type);
    
    // Close button
    const closeButton = document.createElement('button');
    closeButton.className = 'notification-close';
    closeButton.innerHTML = '&times;';
    closeButton.addEventListener('click', (e) => {
      e.stopPropagation();
      this.close(options.id);
    });
    
    // Title
    const titleElement = document.createElement('div');
    titleElement.className = 'notification-title';
    titleElement.textContent = options.title;
    
    // Message
    const messageElement = document.createElement('div');
    messageElement.className = 'notification-message';
    messageElement.textContent = options.message;
    
    // Progress bar
    let progressBar = null;
    if (this.config.showProgress && options.duration > 0) {
      progressBar = document.createElement('div');
      progressBar.className = 'notification-progress';
      
      const progressFill = document.createElement('div');
      progressFill.className = 'notification-progress-fill';
      progressBar.appendChild(progressFill);
    }
    
    // Actions
    let actionsContainer = null;
    if (options.actions && options.actions.length > 0) {
      actionsContainer = document.createElement('div');
      actionsContainer.className = 'notification-actions';
      
      options.actions.forEach(action => {
        const actionButton = document.createElement('button');
        actionButton.className = `notification-action ${action.type || 'default'}`;
        actionButton.textContent = action.label;
        actionButton.addEventListener('click', (e) => {
          e.stopPropagation();
          if (action.callback) {
            action.callback();
          }
          if (options.onAction) {
            options.onAction(action);
          }
          this.close(options.id);
        });
        
        actionsContainer.appendChild(actionButton);
      });
    }
    
    // Build notification
    notification.innerHTML = `
      <div class="notification-icon">${icon}</div>
      <div class="notification-content">
        ${titleElement.outerHTML}
        ${messageElement.outerHTML}
        ${actionsContainer ? actionsContainer.outerHTML : ''}
      </div>
      ${closeButton.outerHTML}
      ${progressBar ? progressBar.outerHTML : ''}
    `;
    
    // Add click handler
    if (options.onClick) {
      notification.addEventListener('click', () => {
        options.onClick();
        this.close(options.id);
      });
    } else if (this.config.closeOnClick) {
      notification.addEventListener('click', () => {
        this.close(options.id);
      });
    }
    
    // Add hover handlers for pause/resume
    if (this.config.pauseOnHover) {
      notification.addEventListener('mouseenter', () => {
        this.pause(options.id);
      });
      
      notification.addEventListener('mouseleave', () => {
        this.resume(options.id);
      });
    }
    
    return notification;
  }
  
  /**
   * Get notification icon based on type
   * @param {string} type - Notification type
   * @returns {string} - Icon HTML
   */
  getNotificationIcon(type) {
    const icons = {
      [NOTIFICATION_TYPES.INFO]: '‚ÑπÔ∏è',
      [NOTIFICATION_TYPES.SUCCESS]: '‚úÖ',
      [NOTIFICATION_TYPES.WARNING]: '‚ö†Ô∏è',
      [NOTIFICATION_TYPES.ERROR]: '‚ùå',
      [NOTIFICATION_TYPES.PAYMENT]: 'üí∞',
      [NOTIFICATION_TYPES.JOB]: 'üíº',
      [NOTIFICATION_TYPES.MESSAGE]: 'üí¨',
      [NOTIFICATION_TYPES.SYSTEM]: 'üîß'
    };
    
    return icons[type] || icons[NOTIFICATION_TYPES.INFO];
  }
  
  /**
   * Start timer for notification
   * @param {string} id - Notification ID
   */
  startTimer(id) {
    const notification = this.notifications.get(id);
    if (!notification || notification.options.duration <= 0) return;
    
    notification.startTime = Date.now();
    notification.paused = false;
    
    notification.timeout = setTimeout(() => {
      this.close(id);
    }, notification.options.duration);
    
    // Start progress animation
    if (this.config.showProgress) {
      this.animateProgress(id);
    }
  }
  
  /**
   * Animate progress bar
   * @param {string} id - Notification ID
   */
  animateProgress(id) {
    const notification = this.notifications.get(id);
    if (!notification) return;
    
    const progressFill = notification.element.querySelector('.notification-progress-fill');
    if (!progressFill) return;
    
    const updateProgress = () => {
      if (notification.paused) return;
      
      const elapsed = Date.now() - notification.startTime;
      const progress = Math.min(elapsed / notification.options.duration, 1);
      
      progressFill.style.width = `${progress * 100}%`;
      notification.progress = progress;
      
      if (progress < 1) {
        requestAnimationFrame(updateProgress);
      }
    };
    
    requestAnimationFrame(updateProgress);
  }
  
  /**
   * Pause notification timer
   * @param {string} id - Notification ID
   */
  pause(id) {
    const notification = this.notifications.get(id);
    if (!notification || !notification.timeout) return;
    
    clearTimeout(notification.timeout);
    notification.timeout = null;
    notification.paused = true;
    
    // Update start time for remaining duration
    const elapsed = Date.now() - notification.startTime;
    notification.options.duration -= elapsed;
  }
  
  /**
   * Resume notification timer
   * @param {string} id - Notification ID
   */
  resume(id) {
    const notification = this.notifications.get(id);
    if (!notification || notification.timeout) return;
    
    this.startTimer(id);
  }
  
  /**
   * Pause all notifications
   */
  pauseAll() {
    this.notifications.forEach((notification, id) => {
      this.pause(id);
    });
  }
  
  /**
   * Resume all notifications
   */
  resumeAll() {
    this.notifications.forEach((notification, id) => {
      this.resume(id);
    });
  }
  
  /**
   * Close a notification
   * @param {string} id - Notification ID
   */
  close(id) {
    const notification = this.notifications.get(id);
    if (!notification) return;
    
    // Clear timeout
    if (notification.timeout) {
      clearTimeout(notification.timeout);
    }
    
    // Animate out
    if (this.config.animateOut) {
      notification.element.classList.remove('show');
      notification.element.classList.add('hide');
      
      setTimeout(() => {
        this.removeNotification(id);
      }, 300);
    } else {
      this.removeNotification(id);
    }
    
    // Call onClose callback
    if (notification.options.onClose) {
      notification.options.onClose();
    }
    
    // Update notification count
    this.updateNotificationCount();
  }
  
  /**
   * Remove notification from DOM and storage
   * @param {string} id - Notification ID
   */
  removeNotification(id) {
    const notification = this.notifications.get(id);
    if (!notification) return;
    
    // Remove from DOM
    if (notification.element.parentNode) {
      notification.element.parentNode.removeChild(notification.element);
    }
    
    // Remove from storage
    this.notifications.delete(id);
  }
  
  /**
   * Close all notifications
   */
  closeAll() {
    this.notifications.forEach((notification, id) => {
      this.close(id);
    });
  }
  
  /**
   * Limit number of notifications
   */
  limitNotifications() {
    if (this.notifications.size > this.config.maxNotifications) {
      const oldestId = Array.from(this.notifications.keys())[0];
      this.close(oldestId);
    }
  }
  
  /**
   * Update notification count
   */
  updateNotificationCount() {
    this.notificationCount = this.notifications.size;
    
    // Update badge if exists
    const badge = document.querySelector('.notification-badge');
    if (badge) {
      if (this.notificationCount > 0) {
        badge.textContent = this.notificationCount > 99 ? '99+' : this.notificationCount;
        badge.style.display = 'flex';
      } else {
        badge.style.display = 'none';
      }
    }
  }
  
  /**
   * Play sound for notification
   * @param {string} type - Notification type
   */
  playSound(type) {
    if (!this.config.soundEnabled) return;
    
    // Create audio context if not exists
    if (!this.audioContext) {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    // Different sounds for different types
    const frequencies = {
      [NOTIFICATION_TYPES.SUCCESS]: [523.25, 659.25, 783.99], // C5, E5, G5
      [NOTIFICATION_TYPES.ERROR]: [349.23, 293.66, 261.63], // F4, D4, C4
      [NOTIFICATION_TYPES.WARNING]: [440, 415.30, 440], // A4, G#4, A4
      [NOTIFICATION_TYPES.INFO]: [523.25, 523.25], // C5, C5
      [NOTIFICATION_TYPES.PAYMENT]: [659.25, 830.61, 1046.50] // E5, G#5, C6
    };
    
    const freq = frequencies[type] || frequencies[NOTIFICATION_TYPES.INFO];
    
    // Play beep sequence
    freq.forEach((frequency, index) => {
      setTimeout(() => {
        this.playBeep(frequency, 0.1);
      }, index * 100);
    });
  }
  
  /**
   * Play a beep sound
   * @param {number} frequency - Frequency in Hz
   * @param {number} duration - Duration in seconds
   */
  playBeep(frequency, duration) {
    try {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
      
      oscillator.start(this.audioContext.currentTime);
      oscillator.stop(this.audioContext.currentTime + duration);
      
    } catch (error) {
      console.error('Failed to play sound:', error);
    }
  }
  
  /**
   * Show desktop notification
   * @param {Object} options - Notification options
   */
  showDesktopNotification(options) {
    if (!('Notification' in window) || this.permission !== 'granted') return;
    
    const notification = new Notification(options.title, {
      body: options.message,
      icon: options.icon || '/images/notification-icon.png',
      tag: options.id,
      data: options.data,
      silent: !options.sound
    });
    
    notification.onclick = () => {
      window.focus();
      notification.close();
      
      if (options.onClick) {
        options.onClick();
      }
    };
    
    notification.onclose = () => {
      if (options.onClose) {
        options.onClose();
      }
    };
    
    // Auto close after duration
    if (options.duration > 0) {
      setTimeout(() => {
        notification.close();
      }, options.duration);
    }
  }
  
  /**
   * Show success notification
   * @param {string|Object} options - Message or options object
   * @returns {string} - Notification ID
   */
  success(options) {
    if (typeof options === 'string') {
      options = { message: options };
    }
    
    return this.show({
      type: NOTIFICATION_TYPES.SUCCESS,
      title: 'Success',
      ...options
    });
  }
  
  /**
   * Show error notification
   * @param {string|Object} options - Message or options object
   * @returns {string} - Notification ID
   */
  error(options) {
    if (typeof options === 'string') {
      options = { message: options };
    }
    
    return this.show({
      type: NOTIFICATION_TYPES.ERROR,
      title: 'Error',
      ...options
    });
  }
  
  /**
   * Show warning notification
   * @param {string|Object} options - Message or options object
   * @returns {string} - Notification ID
   */
  warning(options) {
    if (typeof options === 'string') {
      options = { message: options };
    }
    
    return this.show({
      type: NOTIFICATION_TYPES.WARNING,
      title: 'Warning',
      ...options
    });
  }
  
  /**
   * Show info notification
   * @param {string|Object} options - Message or options object
   * @returns {string} - Notification ID
   */
  info(options) {
    if (typeof options === 'string') {
      options = { message: options };
    }
    
    return this.show({
      type: NOTIFICATION_TYPES.INFO,
      title: 'Info',
      ...options
    });
  }
  
  /**
   * Show payment notification
   * @param {Object} options - Notification options
   * @returns {string} - Notification ID
   */
  payment(options) {
    return this.show({
      type: NOTIFICATION_TYPES.PAYMENT,
      title: 'Payment',
      ...options
    });
  }
  
  /**
   * Show job notification
   * @param {Object} options - Notification options
   * @returns {string} - Notification ID
   */
  job(options) {
    return this.show({
      type: NOTIFICATION_TYPES.JOB,
      title: 'Job Alert',
      ...options
    });
  }
  
  /**
   * Show message notification
   * @param {Object} options - Notification options
   * @returns {string} - Notification ID
   */
  message(options) {
    return this.show({
      type: NOTIFICATION_TYPES.MESSAGE,
      title: 'New Message',
      ...options
    });
  }
  
  /**
   * Update notification configuration
   * @param {Object} config - New configuration
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    
    // Update container position if changed
    if (config.position && this.container) {
      this.container.setAttribute('data-position', config.position);
    }
  }
  
  /**
   * Enable/disable sound
   * @param {boolean} enabled - Whether sound is enabled
   */
  setSoundEnabled(enabled) {
    this.config.soundEnabled = enabled;
  }
  
  /**
   * Enable/disable vibration
   * @param {boolean} enabled - Whether vibration is enabled
   */
  setVibrationEnabled(enabled) {
    this.config.vibrationEnabled = enabled;
  }
  
  /**
   * Enable/disable desktop notifications
   * @param {boolean} enabled - Whether desktop notifications are enabled
   */
  setDesktopNotificationsEnabled(enabled) {
    this.config.desktopNotifications = enabled;
    
    if (enabled && this.permission !== 'granted') {
      this.requestPermission();
    }
  }
  
  /**
   * Get notification by ID
   * @param {string} id - Notification ID
   * @returns {Object|null} - Notification data
   */
  getNotification(id) {
    return this.notifications.get(id) || null;
  }
  
  /**
   * Get all notifications
   * @returns {Array} - Array of notifications
   */
  getAllNotifications() {
    return Array.from(this.notifications.values()).map(n => ({
      id: n.options.id,
      title: n.options.title,
      message: n.options.message,
      type: n.options.type,
      progress: n.progress,
      paused: n.paused
    }));
  }
  
  /**
   * Clear all notifications
   */
  clear() {
    this.closeAll();
  }
  
  /**
   * Destroy notification manager
   */
  destroy() {
    this.closeAll();
    
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
    
    if (this.audioContext) {
      this.audioContext.close();
    }
    
    this.notifications.clear();
    this.container = null;
    this.audioContext = null;
  }
}

// Create default notification manager instance
export const notificationManager = new NotificationManager();

// Export for global use
export default notificationManager;

// Add CSS for notifications
const notificationStyles = `
.notifications-container {
  position: fixed;
  z-index: 9999;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 20px;
  max-width: 400px;
  width: 100%;
  box-sizing: border-box;
}

.notifications-container[data-position="top-left"] {
  top: 0;
  left: 0;
  align-items: flex-start;
}

.notifications-container[data-position="top-right"] {
  top: 0;
  right: 0;
  align-items: flex-end;
}

.notifications-container[data-position="top-center"] {
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  align-items: center;
}

.notifications-container[data-position="bottom-left"] {
  bottom: 0;
  left: 0;
  align-items: flex-start;
}

.notifications-container[data-position="bottom-right"] {
  bottom: 0;
  right: 0;
  align-items: flex-end;
}

.notifications-container[data-position="bottom-center"] {
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  align-items: center;
}

.notification {
  position: relative;
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  padding: 16px;
  min-width: 300px;
  max-width: 400px;
  pointer-events: auto;
  display: flex;
  align-items: flex-start;
  gap: 12px;
  transform: translateY(-20px);
  opacity: 0;
  transition: transform 0.3s ease, opacity 0.3s ease;
  overflow: hidden;
  border-left: 4px solid #3b82f6;
}

.notification.show {
  transform: translateY(0);
  opacity: 1;
}

.notification.hide {
  transform: translateY(20px);
  opacity: 0;
}

.notification-info {
  border-left-color: #3b82f6;
}

.notification-success {
  border-left-color: #10b981;
}

.notification-warning {
  border-left-color: #f59e0b;
}

.notification-error {
  border-left-color: #ef4444;
}

.notification-payment {
  border-left-color: #8b5cf6;
}

.notification-job {
  border-left-color: #06b6d4;
}

.notification-message {
  border-left-color: #ec4899;
}

.notification-system {
  border-left-color: #6b7280;
}

.notification-icon {
  font-size: 20px;
  flex-shrink: 0;
}

.notification-content {
  flex: 1;
  min-width: 0;
}

.notification-title {
  font-weight: 600;
  font-size: 14px;
  margin-bottom: 4px;
  color: #1f2937;
}

.notification-message {
  font-size: 13px;
  color: #6b7280;
  line-height: 1.4;
}

.notification-close {
  background: none;
  border: none;
  font-size: 20px;
  line-height: 1;
  color: #9ca3af;
  cursor: pointer;
  padding: 0;
  margin: -8px -8px 0 0;
  flex-shrink: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: background-color 0.2s, color 0.2s;
}

.notification-close:hover {
  background-color: #f3f4f6;
  color: #374151;
}

.notification-progress {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 3px;
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 0 0 8px 8px;
  overflow: hidden;
}

.notification-progress-fill {
  height: 100%;
  background-color: currentColor;
  width: 0%;
  transition: width 0.1s linear;
}

.notification-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

.notification-action {
  padding: 4px 12px;
  border-radius: 4px;
  border: 1px solid #d1d5db;
  background: white;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.notification-action:hover {
  background-color: #f3f4f6;
  border-color: #9ca3af;
}

.notification-action.primary {
  background-color: #3b82f6;
  border-color: #3b82f6;
  color: white;
}

.notification-action.primary:hover {
  background-color: #2563eb;
  border-color: #2563eb;
}

@media (max-width: 640px) {
  .notifications-container {
    padding: 10px;
    max-width: 100%;
  }
  
  .notification {
    min-width: auto;
    max-width: 100%;
  }
}
`;

// Inject styles
const styleSheet = document.createElement('style');
styleSheet.textContent = notificationStyles;
document.head.appendChild(styleSheet);
EOF
echo "‚úÖ Created: js/notifications.js"

# Create modules directory
echo "Creating module files..."

# File 5: modules/auth.js
cat > js/modules/auth.js << 'EOF'
/**
 * auth.js - Authentication module for Zewed Jobs
 * @version 1.0.0
 */

export class AuthManager {
  constructor() {
    this.currentUser = null;
    this.isAuthenticated = false;
    this.authToken = localStorage.getItem('authToken');
    this.init();
  }
  
  init() {
    if (this.authToken) {
      this.validateToken();
    }
  }
  
  async validateToken() {
    try {
      const response = await fetch('/api/auth/verify', {
        headers: {
          'Authorization': `Bearer ${this.authToken}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        this.currentUser = data.user;
        this.isAuthenticated = true;
        this.onAuthStateChange(true);
      } else {
        this.clearAuth();
      }
    } catch (error) {
      this.clearAuth();
    }
  }
  
  async login(credentials) {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.authToken = data.token;
        this.currentUser = data.user;
        this.isAuthenticated = true;
        
        localStorage.setItem('authToken', data.token);
        localStorage.setItem('user', JSON.stringify(data.user));
        
        this.onAuthStateChange(true);
        return { success: true, data };
      } else {
        return { success: false, error: data.message };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  async register(userData) {
    // Similar to login but with registration endpoint
  }
  
  async logout() {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.authToken}`
        }
      });
    } catch (error) {
      // Continue with client-side logout even if server fails
    } finally {
      this.clearAuth();
    }
  }
  
  clearAuth() {
    this.currentUser = null;
    this.isAuthenticated = false;
    this.authToken = null;
    
    localStorage.removeItem('authToken');
    localStorage.removeItem('user');
    
    this.onAuthStateChange(false);
  }
  
  onAuthStateChange(isAuthenticated) {
    const event = new CustomEvent('authStateChange', {
      detail: { isAuthenticated, user: this.currentUser }
    });
    document.dispatchEvent(event);
  }
}
EOF

# File 6: modules/payment.js
cat > js/modules/payment.js << 'EOF'
/**
 * payment.js - Payment module for Zewed Jobs
 * @version 1.0.0
 */

export class PaymentManager {
  constructor() {
    this.paymentMethods = [];
    this.currentPayment = null;
    this.init();
  }
  
  init() {
    this.loadPaymentMethods();
  }
  
  async loadPaymentMethods() {
    // Load available payment methods
    this.paymentMethods = [
      { id: 'telebirr', name: 'Telebirr', icon: 'üì±', type: 'mobile' },
      { id: 'cbe', name: 'CBE Birr', icon: 'üè¶', type: 'mobile' },
      { id: 'visa', name: 'Visa', icon: 'üí≥', type: 'card' },
      { id: 'mastercard', name: 'MasterCard', icon: 'üí≥', type: 'card' },
      { id: 'paypal', name: 'PayPal', icon: 'üåê', type: 'online' }
    ];
  }
  
  async initiatePayment(amount, method, details = {}) {
    try {
      const response = await fetch('/api/payments/initiate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`
        },
        body: JSON.stringify({
          amount,
          method,
          currency: 'ETB',
          ...details
        })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.currentPayment = data.payment;
        return { success: true, payment: data.payment };
      } else {
        return { success: false, error: data.message };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  async verifyPayment(paymentId) {
    try {
      const response = await fetch(`/api/payments/verify/${paymentId}`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`
        }
      });
      
      const data = await response.json();
      return { success: response.ok, data };
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  getPaymentHistory(filters = {}) {
    // Implement payment history fetching
  }
  
  generateInvoice(paymentId) {
    // Generate and download invoice
    window.open(`/api/payments/invoice/${paymentId}`, '_blank');
  }
}
EOF

# File 7: modules/chatbot.js
cat > js/modules/chatbot.js << 'EOF'
/**
 * chatbot.js - AI Chatbot module for Zewed Jobs
 * @version 1.0.0
 */

export class ChatBot {
  constructor() {
    this.messages = [];
    this.isTyping = false;
    this.conversationId = null;
    this.init();
  }
  
  init() {
    this.loadConversationHistory();
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    const chatInput = document.querySelector('.chat-input');
    const sendButton = document.querySelector('.send-button');
    
    if (chatInput && sendButton) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.sendMessage(chatInput.value);
          chatInput.value = '';
        }
      });
      
      sendButton.addEventListener('click', () => {
        if (chatInput.value.trim()) {
          this.sendMessage(chatInput.value);
          chatInput.value = '';
        }
      });
    }
  }
  
  async sendMessage(text) {
    if (!text.trim() || this.isTyping) return;
    
    // Add user message
    this.addMessage(text, 'user');
    
    // Show typing indicator
    this.showTypingIndicator();
    
    try {
      const response = await fetch('/api/ai/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`
        },
        body: JSON.stringify({
          message: text,
          conversation_id: this.conversationId
        })
      });
      
      const data = await response.json();
      
      // Remove typing indicator
      this.hideTypingIndicator();
      
      if (response.ok) {
        this.addMessage(data.response, 'ai');
        
        if (!this.conversationId) {
          this.conversationId = data.conversation_id;
        }
      } else {
        this.addMessage('Sorry, I encountered an error. Please try again.', 'ai');
      }
    } catch (error) {
      this.hideTypingIndicator();
      this.addMessage('Network error. Please check your connection.', 'ai');
    }
  }
  
  addMessage(text, sender) {
    const message = {
      id: Date.now(),
      text,
      sender,
      timestamp: new Date().toISOString()
    };
    
    this.messages.push(message);
    this.renderMessage(message);
    this.scrollToBottom();
    
    // Save to localStorage
    this.saveConversation();
  }
  
  renderMessage(message) {
    const messagesContainer = document.querySelector('.chat-messages');
    if (!messagesContainer) return;
    
    const messageElement = document.createElement('div');
    messageElement.className = `message ${message.sender}`;
    messageElement.innerHTML = `
      <div class="message-content">${this.formatMessage(message.text)}</div>
      <div class="message-time">${this.formatTime(message.timestamp)}</div>
    `;
    
    messagesContainer.appendChild(messageElement);
  }
  
  formatMessage(text) {
    // Convert markdown-like syntax to HTML
    return text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/`(.*?)`/g, '<code>$1</code>')
      .replace(/\n/g, '<br>');
  }
  
  formatTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  showTypingIndicator() {
    this.isTyping = true;
    
    const messagesContainer = document.querySelector('.chat-messages');
    if (!messagesContainer) return;
    
    const typingElement = document.createElement('div');
    typingElement.className = 'message ai typing';
    typingElement.innerHTML = `
      <div class="typing-indicator">
        <span></span>
        <span></span>
        <span></span>
      </div>
    `;
    typingElement.id = 'typing-indicator';
    
    messagesContainer.appendChild(typingElement);
    this.scrollToBottom();
  }
  
  hideTypingIndicator() {
    this.isTyping = false;
    
    const typingElement = document.getElementById('typing-indicator');
    if (typingElement) {
      typingElement.remove();
    }
  }
  
  scrollToBottom() {
    const messagesContainer = document.querySelector('.chat-messages');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }
  
  loadConversationHistory() {
    const history = localStorage.getItem('chatHistory');
    if (history) {
      this.messages = JSON.parse(history);
      this.messages.forEach(message => this.renderMessage(message));
      this.scrollToBottom();
    }
  }
  
  saveConversation() {
    localStorage.setItem('chatHistory', JSON.stringify(this.messages.slice(-50))); // Keep last 50 messages
  }
  
  clearConversation() {
    this.messages = [];
    this.conversationId = null;
    
    const messagesContainer = document.querySelector('.chat-messages');
    if (messagesContainer) {
      messagesContainer.innerHTML = '';
    }
    
    localStorage.removeItem('chatHistory');
  }
  
  receiveMessage(message) {
    // For real-time messages via WebSocket
    this.addMessage(message.text, message.sender);
  }
}
EOF

# File 8: modules/jobs.js
cat > js/modules/jobs.js << 'EOF'
/**
 * jobs.js - Job management module for Zewed Jobs
 * @version 1.0.0
 */

export class JobManager {
  constructor() {
    this.jobs = [];
    this.savedJobs = new Set();
    this.appliedJobs = new Set();
    this.filters = {};
    this.init();
  }
  
  init() {
    this.loadSavedJobs();
    this.loadAppliedJobs();
  }
  
  async loadJobs(filters = {}) {
    try {
      const queryParams = new URLSearchParams(filters).toString();
      const response = await fetch(`/api/jobs?${queryParams}`);
      const data = await response.json();
      
      if (response.ok) {
        this.jobs = data.jobs;
        return { success: true, jobs: data.jobs };
      } else {
        return { success: false, error: data.message };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  async getJobDetails(jobId) {
    try {
      const response = await fetch(`/api/jobs/${jobId}`);
      const data = await response.json();
      
      if (response.ok) {
        return { success: true, job: data.job };
      } else {
        return { success: false, error: data.message };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  async applyForJob(jobId, applicationData = {}) {
    try {
      const response = await fetch(`/api/jobs/${jobId}/apply`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`
        },
        body: JSON.stringify(applicationData)
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.appliedJobs.add(jobId);
        this.saveAppliedJobs();
        return { success: true, application: data.application };
      } else {
        return { success: false, error: data.message };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  async saveJob(jobId) {
    try {
      const response = await fetch(`/api/jobs/${jobId}/save`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`
        }
      });
      
      if (response.ok) {
        this.savedJobs.add(jobId);
        this.saveSavedJobs();
        return { success: true };
      } else {
        return { success: false };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  async unsaveJob(jobId) {
    try {
      const response = await fetch(`/api/jobs/${jobId}/unsave`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`
        }
      });
      
      if (response.ok) {
        this.savedJobs.delete(jobId);
        this.saveSavedJobs();
        return { success: true };
      } else {
        return { success: false };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  loadSavedJobs() {
    const saved = localStorage.getItem('savedJobs');
    if (saved) {
      this.savedJobs = new Set(JSON.parse(saved));
    }
  }
  
  saveSavedJobs() {
    localStorage.setItem('savedJobs', JSON.stringify([...this.savedJobs]));
  }
  
  loadAppliedJobs() {
    const applied = localStorage.getItem('appliedJobs');
    if (applied) {
      this.appliedJobs = new Set(JSON.parse(applied));
    }
  }
  
  saveAppliedJobs() {
    localStorage.setItem('appliedJobs', JSON.stringify([...this.appliedJobs]));
  }
  
  isJobSaved(jobId) {
    return this.savedJobs.has(jobId);
  }
  
  isJobApplied(jobId) {
    return this.appliedJobs.has(jobId);
  }
  
  filterJobs(filters) {
    this.filters = { ...this.filters, ...filters };
    return this.jobs.filter(job => {
      // Apply all filters
      return Object.entries(this.filters).every(([key, value]) => {
        if (!value) return true;
        
        switch (key) {
          case 'search':
            return job.title.toLowerCase().includes(value.toLowerCase()) ||
                   job.company.toLowerCase().includes(value.toLowerCase()) ||
                   job.description.toLowerCase().includes(value.toLowerCase());
          case 'location':
            return job.location.toLowerCase().includes(value.toLowerCase());
          case 'category':
            return job.category === value;
          case 'type':
            return job.type === value;
          case 'salary_min':
            return job.salary >= value;
          case 'salary_max':
            return job.salary <= value;
          default:
            return true;
        }
      });
    });
  }
  
  sortJobs(sortBy, order = 'desc') {
    return [...this.jobs].sort((a, b) => {
      let valueA = a[sortBy];
      let valueB = b[sortBy];
      
      if (sortBy === 'salary') {
        valueA = parseInt(valueA) || 0;
        valueB = parseInt(valueB) || 0;
      } else if (sortBy === 'posted_date') {
        valueA = new Date(valueA);
        valueB = new Date(valueB);
      }
      
      if (order === 'asc') {
        return valueA > valueB ? 1 : -1;
      } else {
        return valueA < valueB ? 1 : -1;
      }
    });
  }
}
EOF

# Create utils directory
echo "Creating utility files..."

# File 9: utils/helpers.js
cat > js/utils/helpers.js << 'EOF'
/**
 * helpers.js - Utility functions for Zewed Jobs
 * @version 1.0.0
 */

/**
 * Debounce function
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} - Debounced function
 */
export function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Throttle function
 * @param {Function} func - Function to throttle
 * @param {number} limit - Time limit in milliseconds
 * @returns {Function} - Throttled function
 */
export function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

/**
 * Format currency
 * @param {number} amount - Amount to format
 * @param {string} currency - Currency code
 * @returns {string} - Formatted currency
 */
export function formatCurrency(amount, currency = 'ETB') {
  return new Intl.NumberFormat('en-ET', {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  }).format(amount);
}

/**
 * Format date
 * @param {Date|string} date - Date to format
 * @param {string} format - Date format
 * @returns {string} - Formatted date
 */
export function formatDate(date, format = 'medium') {
  const dateObj = new Date(date);
  const options = {
    short: { day: 'numeric', month: 'short' },
    medium: { day: 'numeric', month: 'short', year: 'numeric' },
    long: { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }
  };
  
  return dateObj.toLocaleDateString('en-ET', options[format] || options.medium);
}

/**
 * Validate email address
 * @param {string} email - Email to validate
 * @returns {boolean} - True if email is valid
 */
export function validateEmail(email) {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
}

/**
 * Validate phone number
 * @param {string} phone - Phone number to validate
 * @returns {boolean} - True if phone is valid
 */
export function validatePhone(phone) {
  const re = /^(\+251|0)(9|7)[0-9]{8}$/;
  return re.test(phone.replace(/\s/g, ''));
}

/**
 * Generate unique ID
 * @param {number} length - Length of ID
 * @returns {string} - Unique ID
 */
export function generateId(length = 8) {
  return Math.random().toString(36).substr(2, length);
}

/**
 * Create loading spinner
 * @param {HTMLElement} container - Container element
 * @returns {HTMLElement} - Spinner element
 */
export function createLoadingSpinner(container) {
  const spinner = document.createElement('div');
  spinner.className = 'loading-spinner';
  spinner.innerHTML = `
    <div class="spinner"></div>
    <div class="spinner-text">Loading...</div>
  `;
  
  if (container) {
    container.appendChild(spinner);
  }
  
  return spinner;
}

/**
 * Remove loading spinner
 * @param {HTMLElement} container - Container element
 */
export function removeLoadingSpinner(container) {
  const spinner = container.querySelector('.loading-spinner');
  if (spinner) {
    spinner.remove();
  }
}

/**
 * Copy text to clipboard
 * @param {string} text - Text to copy
 * @returns {Promise} - Copy promise
 */
export async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    return { success: true };
  } catch (error) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    return { success: true };
  }
}

/**
 * Get URL parameters
 * @param {string} url - URL to parse
 * @returns {Object} - URL parameters
 */
export function getUrlParams(url = window.location.href) {
  const params = {};
  const urlObj = new URL(url);
  
  urlObj.searchParams.forEach((value, key) => {
    params[key] = value;
  });
  
  return params;
}

/**
 * Set URL parameters
 * @param {Object} params - Parameters to set
 * @param {string} url - Base URL
 * @returns {string} - New URL
 */
export function setUrlParams(params, url = window.location.href) {
  const urlObj = new URL(url);
  
  Object.entries(params).forEach(([key, value]) => {
    if (value === null || value === undefined) {
      urlObj.searchParams.delete(key);
    } else {
      urlObj.searchParams.set(key, value);
    }
  });
  
  return urlObj.toString();
}

/**
 * Format file size
 * @param {number} bytes - Size in bytes
 * @returns {string} - Formatted size
 */
export function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Sanitize HTML
 * @param {string} html - HTML to sanitize
 * @returns {string} - Sanitized HTML
 */
export function sanitizeHTML(html) {
  const temp = document.createElement('div');
  temp.textContent = html;
  return temp.innerHTML;
}

/**
 * Detect device type
 * @returns {string} - Device type
 */
export function detectDevice() {
  const ua = navigator.userAgent;
  
  if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) {
    return 'tablet';
  }
  
  if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(ua)) {
    return 'mobile';
  }
  
  return 'desktop';
}

/**
 * Check if element is in viewport
 * @param {HTMLElement} element - Element to check
 * @returns {boolean} - True if element is in viewport
 */
export function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

/**
 * Smooth scroll to element
 * @param {string|HTMLElement} target - Target element or selector
 * @param {Object} options - Scroll options
 */
export function smoothScrollTo(target, options = {}) {
  const element = typeof target === 'string' ? document.querySelector(target) : target;
  
  if (!element) return;
  
  const { offset = 0, duration = 500 } = options;
  
  const startPosition = window.pageYOffset;
  const targetPosition = element.getBoundingClientRect().top + startPosition - offset;
  const distance = targetPosition - startPosition;
  let startTime = null;
  
  function animation(currentTime) {
    if (startTime === null) startTime = currentTime;
    const timeElapsed = currentTime - startTime;
    const run = easeInOutQuad(timeElapsed, startPosition, distance, duration);
    window.scrollTo(0, run);
    
    if (timeElapsed < duration) {
      requestAnimationFrame(animation);
    }
  }
  
  function easeInOutQuad(t, b, c, d) {
    t /= d / 2;
    if (t < 1) return c / 2 * t * t + b;
    t--;
    return -c / 2 * (t * (t - 2) - 1) + b;
  }
  
  requestAnimationFrame(animation);
}

/**
 * Format Ethiopian date
 * @param {Date} date - Date to format
 * @returns {string} - Ethiopian date
 */
export function formatEthiopianDate(date) {
  // Ethiopian calendar conversion logic
  // This is a simplified version
  const ethiopianMonths = [
    '·àò·àµ·ä®·à®·àù', '·å•·âÖ·àù·âµ', '·äÖ·ã≥·à≠', '·â≥·äÖ·à£·à•', 
    '·å•·à≠', '·ã®·ä´·â≤·âµ', '·àò·åã·â¢·âµ', '·àö·ã´·ãù·ã´', 
    '·åç·äï·â¶·âµ', '·à∞·äî', '·àê·àù·àå', '·äê·àê·à¥', '·å≥·åâ·àú'
  ];
  
  // For demo purposes, return a placeholder
  return `${date.getDate()} ${ethiopianMonths[date.getMonth()]} ${date.getFullYear()}`;
}

/**
 * Convert Amharic to Latin
 * @param {string} text - Amharic text
 * @returns {string} - Latin text
 */
export function amharicToLatin(text) {
  const mapping = {
    '·àÄ': 'ha', '·àÅ': 'hu', '·àÇ': 'hi', '·àÉ': 'ha', '·àÑ': 'he', '·àÖ': 'h', '·àÜ': 'ho',
    '·àà': 'le', '·àâ': 'lu', '·àä': 'li', '·àã': 'la', '·àå': 'le', '·àç': 'l', '·àé': 'lo',
    // Add more mappings as needed
  };
  
  return text.split('').map(char => mapping[char] || char).join('');
}

/**
 * Get current Ethiopian time
 * @returns {Date} - Ethiopian time
 */
export function getEthiopianTime() {
  const now = new Date();
  // Ethiopia is UTC+3
  const ethiopianTime = new Date(now.getTime() + (3 * 60 * 60 * 1000));
  return ethiopianTime;
}

/**
 * Calculate time ago
 * @param {Date} date - Date to calculate from
 * @returns {string} - Time ago string
 */
export function timeAgo(date) {
  const now = new Date();
  const past = new Date(date);
  const seconds = Math.floor((now - past) / 1000);
  
  let interval = Math.floor(seconds / 31536000);
  if (interval >= 1) {
    return interval + ' year' + (interval === 1 ? '' : 's') + ' ago';
  }
  
  interval = Math.floor(seconds / 2592000);
  if (interval >= 1) {
    return interval + ' month' + (interval === 1 ? '' : 's') + ' ago';
  }
  
  interval = Math.floor(seconds / 86400);
  if (interval >= 1) {
    return interval + ' day' + (interval === 1 ? '' : 's') + ' ago';
  }
  
  interval = Math.floor(seconds / 3600);
  if (interval >= 1) {
    return interval + ' hour' + (interval === 1 ? '' : 's') + ' ago';
  }
  
  interval = Math.floor(seconds / 60);
  if (interval >= 1) {
    return interval + ' minute' + (interval === 1 ? '' : 's') + ' ago';
  }
  
  return 'Just now';
}

/**
 * Generate random color
 * @returns {string} - Hex color code
 */
export function getRandomColor() {
  const letters = '0123456789ABCDEF';
  let color = '#';
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

/**
 * Generate avatar from name
 * @param {string} name - Full name
 * @returns {string} - Avatar URL or data
 */
export function generateAvatar(name) {
  const initials = name
    .split(' ')
    .map(part => part.charAt(0))
    .join('')
    .toUpperCase()
    .substring(0, 2);
  
  const colors = [
    '#3B82F6', '#10B981', '#F59E0B', '#EF4444',
    '#8B5CF6', '#06B6D4', '#EC4899', '#84CC16'
  ];
  
  const color = colors[initials.charCodeAt(0) % colors.length];
  
  return `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="${color}"/><text x="50" y="50" font-family="Arial" font-size="40" fill="white" text-anchor="middle" dy=".3em">${initials}</text></svg>`;
}

/**
 * Deep clone object
 * @param {Object} obj - Object to clone
 * @returns {Object} - Cloned object
 */
export function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Merge objects deeply
 * @param {...Object} objects - Objects to merge
 * @returns {Object} - Merged object
 */
export function deepMerge(...objects) {
  const result = {};
  
  objects.forEach(obj => {
    if (obj) {
      Object.keys(obj).forEach(key => {
        if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
          result[key] = deepMerge(result[key] || {}, obj[key]);
        } else {
          result[key] = obj[key];
        }
      });
    }
  });
  
  return result;
}
EOF

echo ""
echo "üéâ JavaScript structure created successfully!"
echo ""
echo "üìÅ Directory structure:"
find js -type f -name "*.js" | sort
echo ""
echo "üöÄ How to use:"
echo "1. Include main.js in your HTML:"
echo "   <script type=\"module\" src=\"/js/main.js\"></script>"
echo ""
echo "2. Or bundle all files:"
echo "   npm run build"
echo ""
echo "3. Available modules:"
echo "   - main.js: Main application"
echo "   - api.js: API communication"
echo "   - translator.js: Multi-language support"
echo "   - notifications.js: Toast & push notifications"
echo "   - modules/: Additional feature modules"
echo "   - utils/: Utility functions"
echo ""
echo "üì¶ To bundle for production:"
echo "   Install esbuild: npm install esbuild"
echo "   Create bundle: npx esbuild js/main.js --bundle --outfile=dist/bundle.js --minify"
